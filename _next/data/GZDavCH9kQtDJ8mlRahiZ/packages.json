{"pageProps":{"allPackageData":[{"slug":"appy","metadata":{"name":"@execonline-inc/appy","description":"Call api patterns around ajaxian http tasks"},"markdown":{"content":"# `appy`\n\nThe `appy` package provides functions to interface with HATEOAS API endpoints.\n\n## Types\n\n### `MissingApplicationId`\n\n```ts\ninterface MissingApplicationId {\n  kind: 'missing-application-id';\n}\n```\n\n### `AppyError`\n\n```ts\nimport { MissingApplicationId } from '@execonline-inc/appy';\nimport { HttpError } from 'ajaxian';\n\ntype AppyError = HttpError | MissingApplicationId;\n```\n\n### `HReferenceable`\n\n```ts\nimport { HttpError, Method } from 'ajaxian';\n\ninterface HReferenceable {\n  href: string;\n  method: Method;\n}\n```\n\n## Functions\n\n### `request`\n\nThis curried function creates an HTTP request `Task` using a given authentication token, HATEOAS link, and payload data, and decodes the response using the given decoder.\n\n```ts\nimport { AppyError, HReferenceable, request } from '@execonline-inc/appy';\nimport Decoder, { succeed } from 'jsonous';\nimport { Maybe, just } from 'maybeasy';\nimport { Task } from 'taskarian';\n\nconst token: Maybe<string> = just('3ad1afde-6d9f-4e29-97d4-4396f891267f');\nconst link: HReferenceable = { href: 'https://example.com/', method: 'get' };\ninterface Response {}\nconst decoder: Decoder<Response> = succeed({});\nconst payload = {};\n\nconst req: Task<AppyError, RequestBuilder<Response>> = request(token)(link, decoder, payload);\n```\n\n### `callApi`\n\nSimilar to `request`, this function creates an HTTP request `Task`. The significant differences are that a given `Task` is executed when the response indicates that the authentication is invalid, and the ultimate return value is an object of the decoded type itself, not one wrapped in a `RequestBuilder` object.\n\n```ts\nimport { AppyError, callApi, HReferenceable } from '@execonline-inc/appy';\nimport Decoder, { succeed } from 'jsonous';\nimport { Maybe, just } from 'maybeasy';\nimport { Task } from 'taskarian';\n\nconst token: Maybe<string> = just('3ad1afde-6d9f-4e29-97d4-4396f891267f');\nconst link: HReferenceable = { href: 'https://example.com/', method: 'get' };\nconst whenUnauthenticated: Task<never, void> = new Task(() => noop);\ninterface Response {}\nconst decoder: Decoder<Response> = succeed({});\nconst payload = {};\n\nconst req: Task<AppyError, Response> = callApi(token)(whenUnauthenticated)(decoder, payload)(link);\n```\n\n### `postToApi`\n\nSimilar to `callApi`, this function creates an HTTP request `Task`, but it's hardcoded for the `post` verb and does not decode the response.\n\n```ts\nimport { AppyError, HReferenceable, postToApi } from '@execonline-inc/appy';\nimport { Maybe, just } from 'maybeasy';\nimport { Task } from 'taskarian';\n\nconst token: Maybe<string> = just('3ad1afde-6d9f-4e29-97d4-4396f891267f');\nconst link: HReferenceable = { href: 'https://example.com/', method: 'post' };\nconst whenUnauthenticated: Task<never, void> = new Task(() => noop);\nconst payload = {};\n\nconst req: Task<AppyError, string> = postToApi(token)(whenUnauthenticated)(payload)(link);\n```\n\n### `putToApi`\n\nSimilar to `callApi`, this function creates an HTTP request `Task`, but it's hardcoded for the `put` verb and does not decode the response.\n\n```ts\nimport { AppyError, HReferenceable, putToApi } from '@execonline-inc/appy';\nimport { Maybe, just } from 'maybeasy';\nimport { Task } from 'taskarian';\n\nconst token: Maybe<string> = just('3ad1afde-6d9f-4e29-97d4-4396f891267f');\nconst link: HReferenceable = { href: 'https://example.com/', method: 'put' };\nconst whenUnauthenticated: Task<never, void> = new Task(() => noop);\nconst payload = {};\n\nconst req: Task<AppyError, string> = putToApi(token)(whenUnauthenticated)(payload)(link);\n```\n\n### `deleteToApi`\n\nSimilar to `callApi`, this function creates an HTTP request `Task`, but it's hardcoded for the `delete` verb, does not decode the response, and does not accept request payload data.\n\n```ts\nimport { AppyError, deleteToApi, HReferenceable } from '@execonline-inc/appy';\nimport { Maybe, just } from 'maybeasy';\nimport { Task } from 'taskarian';\n\nconst token: Maybe<string> = just('3ad1afde-6d9f-4e29-97d4-4396f891267f');\nconst link: HReferenceable = { href: 'https://example.com/', method: 'delete' };\nconst whenUnauthenticated: Task<never, void> = new Task(() => noop);\n\nconst req: Task<AppyError, string> = deleteToApi(token)(whenUnauthenticated)(link);\n```\n\n### `getFromApi`\n\nSimilar to `callApi`, this function creates an HTTP request `Task`, but it's hardcoded for the `get` verb and does not decode the response.\n\n```ts\nimport { AppyError, getFromApi, HReferenceable } from '@execonline-inc/appy';\nimport { Maybe, just } from 'maybeasy';\nimport { Task } from 'taskarian';\n\nconst token: Maybe<string> = just('3ad1afde-6d9f-4e29-97d4-4396f891267f');\nconst link: HReferenceable = { href: 'https://example.com/', method: 'get' };\nconst whenUnauthenticated: Task<never, void> = new Task(() => noop);\nconst payload = {};\n\nconst req: Task<AppyError, string> = getFromApi(token)(whenUnauthenticated)(payload)(link);\n```\n\n### `getRespFromApi`\n\nSimilar to `callApi`, this function creates an HTTP request `Task`, but it's hardcoded for the `get` verb, does not decode the response, and returns the entire successful response object rather than just its body.\n\n```ts\nimport { AppyError, getRespFromApi, HReferenceable } from '@execonline-inc/appy';\nimport { Maybe, just } from 'maybeasy';\nimport { Task } from 'taskarian';\n\nconst token: Maybe<string> = just('3ad1afde-6d9f-4e29-97d4-4396f891267f');\nconst link: HReferenceable = { href: 'https://example.com/', method: 'get' };\nconst whenUnauthenticated: Task<never, void> = new Task(() => noop);\nconst payload = {};\n\nconst req: Task<AppyError, HttpSuccess<string>> = getRespFromApi(token)(whenUnauthenticated)(\n  payload\n)(link);\n```\n"}},{"slug":"collections","metadata":{"name":"@execonline-inc/collections","description":"Utilities for working with collections of data"},"markdown":{"content":"# `collections`\n\nThe `collections` package provides functions to work with lists in various ways.\n\n## Functions\n\n### `bifurcateWhen`\n\nThis function splits an array once the provided function evaluates to `true` for an element of that array. The element that resulted in the `true` evaluation is the first element of the second returned array.\n\n```ts\nimport { bifurcateWhen } from '@execonline-inc/collections';\n\nconst list = [1, 2, 3, 4, 5];\nconst result = bifurcateWhen((item: number): boolean => item === 3, list);\n// [[1, 2], [3, 4, 5]]\n```\n\n### `bifurcateBy`\n\nThis function splits an array by the evaluation of the provided function. Array elements that evaluate to `true` are returned as the first bifurcated array, those that evaluate to `false` are returned as the second bifurcated array.\n\n```ts\nimport { bifurcateBy } from '@execonline-inc/collections';\n\nconst list = [1, 2, 3, 4, 5];\nconst isEven = (item: number): boolean => !(item % 2);\nconst result = bifurcateBy(isEven, list);\n// [[2, 4], [1, 3, 5]]\n```\n\n### `concat`\n\nThis curried function simply concatenates two arrays.\n\n```ts\nimport { concat } from '@execonline-inc/collections';\n\nconst listA = [1, 2, 3];\nconst listB = [4, 5, 6];\n\nconst result = concat(listA)(listB);\n// [1, 2, 3, 4, 5, 6]\n```\n\n### `concatAll`\n\nThis function takes an array of arrays, and concatenates them all in order.\n\n```ts\nimport { concatAll } from '@execonline-inc/collections';\n\nconst lists = [\n  [1, 2, 3],\n  [4, 5, 6],\n  [7, 8, 9],\n];\n\nconst result: number[] = concatAll(lists);\n// [1, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n\n### `drop`\n\n`drop` creates a new array by dropping the specified number of items from the front of the array.\n\nThis function has a curried and non-curried form.\n\n```ts\nimport { drop } from '@execonline-inc/collections';\n\nconst list = [1, 2, 3, 4, 5];\nconst result = drop(3)(list);\n// [ 4, 5 ]\n```\n\n### `dropUntil`\n\nThis function has a curried and non-curried form. It takes an evaluation function and an array.\n\nThe evaluation function is called on elements of the array until it evaluates to `true`. The element that caused the function to evaluate to `true` and subsequent elements of the array are returned in a new array.\n\n```ts\nimport { dropUntil } from '@execonline-inc/collections';\n\nconst list = [1, 2, 3, 4, 5];\nconst result: number[] = dropUntil((item: number): boolean => item === 3)(list);\n// [3, 4, 5]\n```\n\n### `uniqBy`\n\nThis curried function takes a transformation function and an array. Each element of the array is passed to the transformation function. Duplicate evaluations of this function exlude the corresponding original element from the returned array.\n\n```ts\nimport { uniqBy } from '@execonline-inc/collections';\n\nconst list = [1, 2, 3, 4, 5];\nconst result: number[] = uniqBy((item: number): string => (item > 3 ? String(item) : ''));\n// [1, 4, 5]\n```\n\n### `uniq`\n\nThis function returns only the unique elements of a given array.\n\n```ts\nimport { uniq } from '@execonline-inc/collections';\n\nconst list = [1, 1, 2, 3, 3];\nconst result: number[] = uniq(list);\n// [1, 2, 3]\n```\n\n### `find`\n\n`find` returns the first matching element in an Array.\n\nMatching is determined by the function passed as the first argument.\nIf it returns true, then a match has been identified.\n\nIf a match is found, the item is return wrapped in a `Just`.\nOtherwise, a `Nothing` is returned.\n\nThis function has a curried and non-curried form.\n\n```ts\nimport { find } from '@execonline-inc/collections';\nimport { Maybe } from 'maybeasy';\n\nconst list = [1, 2, 3];\nconst result: Maybe<number> = find((item: number): boolean => item === 2)(list);\n// Just<2>\n```\n\n### `findIndex`\n\n`findIndex` takes an evaluation function and an array.\n\nThe evaluation function is called on elements of the array until it evaluates to `true`, at which point that element's index is returned as a `Just`. If no element is found, a `Nothing` iss returned.\n\nThis function has a curried and non-curried form.\n\n```ts\nimport { findIndex } from '@execonline-inc/collections';\nimport { Maybe } from 'maybeasy';\n\nconst list = [1, 2, 3];\nconst result: Maybe<number> = findIndex((item: number): boolean => item === 2)(list);\n// Just<1>\n```\n\n### `findR`\n\nThis curried function operates like `find<T>`, but returns a `Result<NothingFound, T>` instead of a `Maybe<T>`.\n\n```ts\nimport { findR, NothingFound } from '@execonline-inc/collections';\n\nconst list = [1, 2, 3];\nconst result: Result<NothingFound, number> = findR((item: number): boolean => item === 4)(list);\n// Err<NothingFound>\n```\n\n### `findItem`\n\nThis curried function finds the first item of the given ID in an array of objects of the interface `{ id: number }`.\n\n```ts\nimport { findItem } from '@execonline-inc/collections';\nimport { Maybe } from 'maybeasy';\n\nconst list = [{ id: 1 }, { id: 2 }, { id: 3 }];\nconst result: Maybe<{ id: number }> = findItem(2)(list);\n// Just<{ id: 2 }>\n```\n\n### `findItemT`\n\nThis curried function wraps `findItem` functionality in a `Task`. It is particularly useful in chaining of tasks:\n\n```ts\nimport { findItemT, ItemNotFound } from '@execonline-inc/collections';\nimport { Task } from 'taskarian';\n\nconst list = [{ id: 1 }, { id: 2 }, { id: 3 }];\nconst task = Task.succeed<ItemNotFound, { id: number }[]>(list);\n\nconst example: Task<ItemNotFound, { id: 2 }> = task.andThen(findItemT(2));\n```\n\n### `findPayload`\n\n`findPayload` accepts an ID and a list of payloads of a `{ payload: { id: number } }` interface and returns the first payload with the matching ID as a `Maybe`.\n\nThis function has a curried and non-curried form\n\n```ts\nimport { findPayload } from '@execonline-inc/collections';\nimport { Maybe } from 'maybeasy';\n\nconst payloads = [{ payload: { id: 1 } }, { payload: { id: 2 } }, { payload: { id: 3 } }];\nconst result: Maybe<{ payload: { id: number } }> = findPayload(2)(payloads);\n// Just<{ payload: { id: 2 } }>\n```\n\n### `findPayloadT`\n\nSame as `findItemT` but with the functionality of `findPayload`.\n\n```ts\nimport { findPayloadT, PayloadNotFound } from '@execonline-inc/collections';\nimport { Task } from 'taskarian';\n\nconst payloads = [{ payload: { id: 1 } }, { payload: { id: 2 } }, { payload: { id: 3 } }];\nconst task = Task.succeed<PayloadNotFound, { payload: { id: number } }[]>(payloads);\n\nconst example: Task<PayloadNotFound, { payload: { id: 2 } }> = task.andThen(findPayloadT(2));\n```\n\n### `findPayloadByUuid`\n\nSame as `findPayload` but takes a `string` as the UUID to find and a list of payloads of a `{ payload: { uuid: string } }` interface.\n\n```ts\nimport { findPayloadByUuid } from '@execonline-inc/collections';\nimport { Maybe } from 'maybeasy';\n\nconst payloads = [\n  { payload: { uuid: 'cb08aa12-30f3-48b4-a6ec-bb95ca1e021d' } },\n  { payload: { uuid: 'e1da03ff-46ff-49c9-bb69-a09ea68fbd76' } },\n  { payload: { uuid: 'ea4c9aa3-b39b-4c3c-a931-b1bbc921970c' } },\n];\nconst result: Maybe<{ payload: { id: number } }> = findPayloadByUuid(\n  'cb08aa12-30f3-48b4-a6ec-bb95ca1e021d'\n)(payloads);\n// Just<{ payload: { uuid: 'cb08aa12-30f3-48b4-a6ec-bb95ca1e021d' } }>\n```\n\n### `groupBy`\n\nThis curried function takes a function to derive the group key for each element and an array of items.\n\n```ts\nimport { groupBy } from '@execonline-inc/collections';\n\nconst list = ['abc-123', 'abc-456', 'def-789'];\nconst result = groupBy((item: string): string => item.split('-').shift())(list);\n// { 'abc': ['abc-123', 'abc-456'], 'def': ['def-789'] }\n```\n\n### `toPairs`\n\nThis function takes an object and returns an array of key-value pairs.\n\n```ts\nimport { toPairs } from '@execonline-inc/collections';\n\nconst obj = {\n  abc: 123,\n  def: 456,\n};\nconst result = toPairs(obj);\n// [['abc', 123], ['def', 456]]\n```\n\n### `map`\n\nThis curried function takes a transformation function and a list of items to return a new list of items.\n\n```ts\nimport { map } from '@execonline-inc/collections';\n\nconst list = [1, 2, 3];\nconst result: number[] = map((item: number): number => item + 10)(list);\n// [11, 12, 13]\n```\n\n### `flatMap`\n\n`flatMap` takes a list of items and a transformation function that returns an array for each item. The final return value is a flattened array of each of those resulting arrays.\n\nThis function has curried and non-curried form.\n\n```ts\nimport { flatMap } from '@execonline-inc/collections';\n\nconst list = [1, 2, 3];\nconst result = flatMap((item: number): number[] => [10, 100, 1000].map(n => n * item))(list);\n// [10, 100, 1000, 20, 200, 2000, 30, 300, 3000]\n```\n\n### `mapMaybe`\n\n`mapMaybe` takes a list of items and a function that maps each item of the array to a `Maybe`. The final return value is an array of only the mapped values that were a `Just`.\n\nThis function has curried and non-curried form.\n\n```ts\nimport { mapMaybe } from '@execonline-inc/collections';\nimport { Maybe } from 'maybeasy';\n\nconst list = [1, 2, 3, 4, 5, 6];\nconst result = mapMaybe(\n  (item: number): Maybe<number> => item % 2 ? nothing() : just(item);\n)(list);\n// [2, 4, 6]\n```\n\n### `byId`\n\nThis curried function checks whether the given ID matches the ID in the given payload.\n\n```ts\nimport { byId } from '@execonline-inc/collections';\n\nconst payload = { id: 123 };\nconst result: boolean = byId(123)(payload);\n```\n\n### `byPayloadId`\n\nThis curried function checks whether the given ID matches the ID in the given resource.\n\n```ts\nimport { byPayloadId } from '@execonline-inc/collections';\n\nconst resource = { payload: { id: 123 } };\nconst result: boolean = byPayloadId(123)(resource);\n```\n\n### `byPayloadUuid`\n\nThis curried function checks whether the given UUID matches the UUID in the given resource.\n\n```ts\nimport { byPayloadUuid } from '@execonline-inc/collections';\n\nconst resource = { payload: { id: '9f925583-7a8f-4459-979d-5ad2d5ede2f8' } };\nconst result: boolean = byPayloadUuid('9f925583-7a8f-4459-979d-5ad2d5ede2f8')(resource);\n```\n\n### `sort`\n\n`sort` provides stable sorting of an array using a given comparison function.\n\nThe comparison function should return:\n\n- `< 0` to sort `a` before `b`\n- `0` to consider `a` equal to `b`\n- `> 0` to sort `a` after `b`\n\nThis function has a curried and non-curried form.\n\n```ts\nimport { sort } from '@execonline-inc/collections';\n\nconst list = [\n  { age: 30, name: 'Ava' },\n  { age: 25, name: 'Bob' },\n  { age: 20, name: 'Cas' },\n  { age: 25, name: 'Dan' },\n];\nconst result = sort((a, b) => a.age - b.age)(list);\n// [{ age: 20, name: 'Cas' }, { age: 25, nam: 'Bob' }, { age: 25, name: 'Dan' }, { age: 30, name: 'Ava' }]\n```\n\n### `take`\n\n`take` creates a new array of the specified amount of items from the given array from its beginning.\n\nThis function has a curried and non-curried form.\n\n```ts\nimport { take } from '@execonline-inc/collections';\n\nconst list = [1, 2, 3, 4, 5];\nconst result = take(3)(list);\n// [1, 2, 3]\n```\n\n### `first`\n\nThis function returns the first item from an array. When present, the item is wrapped in a `Just`, otherwise the return value is a `Nothing`.\n\n```ts\nimport { first } from '@execonline-inc/collections';\n\nconst list = [1, 2, 3];\nconst result = first(list);\n// Just<1>\n```\n\n### `last`\n\nThis function returns the last item from an array. When present, the item is wrapped in a `Just`, otherwise the return value is a `Nothing`.\n\n```ts\nimport { last } from '@execonline-inc/collections';\n\nconst list = [1, 2, 3];\nconst result = last(list);\n// Just<3>\n```\n\n### `takeLastUntil`\n\n`takeLastUntil` returns a new array of the items from the end of the given array until the given function evalutes `true`.\n\nThis function has a curried and non-curried form.\n\n```ts\nimport { takeLastUntil } from '@execonline-inc/collections';\n\nconst list = [1, 2, 3, 4, 5];\nconst result = takeLastUntil((item: number): boolean => item === 3)(list);\n// [4, 5]\n```\n\n### `takeLastWhile`\n\n`takeLastWhile` returns a new array of the items from the end of the given array while the given function evaluates `true`.\n\nThis function has a curried and non-curried form.\n\n```ts\nimport { takeLastWhile } from '@execonline-inc/collections';\n\nconst list = [1, 2, 3, 4, 5];\nconst result = takeLastWhile((item: number): boolean => item > 3)(list);\n// [4, 5]\n```\n"}},{"slug":"decoders","metadata":{"name":"@execonline-inc/decoders","description":"Generally useful decoders that extend Jsonous"},"markdown":{"content":"# `decoders`\n\nThe `decoders` package provides useful utility decoder implementations.\n\n```ts\nimport * as decoders from '@execonline-inc/decoders';\n\nimport Decoder, { fail, field, succeed } from 'jsonous';\nimport { fromEmpty, Maybe } from 'maybeasy';\nimport { Result } from 'resulty';\n```\n\n## Functions\n\n### `eql`, `stringLiteral`\n\nThe `eql` decoder decodes for a specific value rather than some type. The `stringLiteral` decoder is an application of the `eql` decoder for just `string` values.\n\n```ts\nimport { eql } from '@execonline-inc/decoders';\nimport Decoder from 'jsonous';\nimport { Result } from 'resulty';\n\nconst example: Decoder<123> = eql<123>(123);\nconst result: Result<string, 123> = example.decodeAny(123);\n```\n\n```ts\nimport { stringLiteral } from '@execonline-inc/decoders';\nimport Decoder from 'jsonous';\nimport { Result } from 'resulty';\n\nconst example: Decoder<'abc'> = stringLiteral('abc');\nconst result: Result<string, 'abc'> = example.decodeAny('abc');\n```\n\n### `regexDecoder`\n\n```ts\nimport { regexDecoder } from '@execonline-inc/decoders';\nimport Decoder, { fail, succeed } from 'jsonous';\n\nconst example: Decoder<string> = regexDecoder(/(abc)/).andThen(result =>\n  fromEmpty(result[1]).map(str => succeed(str).getOrElse(() => fail('Could not find \"abc\"')))\n);\n```\n\n### `nullableBlankString`\n\nThis decoder handles a value that should be a string but could also be `null` or `undefined` and converts it to a `Maybe`.\n\n```ts\nimport { nullableBlankString } from '@execonline-inc/decoders';\nimport Decoder from 'jsonous';\nimport { Result } from 'resulty';\n\nconst example: Decoder<Maybe<string>> = nullableBlankString;\nconst result: Result<string, Maybe<string>> = example.decodeAny('abc');\n```\n\n### `base64Decoder`\n\nThis decoder decodes input as base64 using the browser's `atob` function. A decoder error is the result from any thrown errors.\n\n```ts\nimport { base64Decoder } from '@execonline-inc/decoders';\nimport Decoder from 'jsonous';\nimport { Result } from 'resulty';\n\nconst example: Decoder<string> = base64Decoder;\nconst result: Result<string, string> = example.decodeAny('aGVsbG8=');\n```\n\n### `jsonParserDecoder`\n\nThis decoder takes a decoder whose output is parsed as JSON. If JSON parsing fails, then a decoder error is the result.\n\n```ts\nimport { base64Decoder, jsonParserDecoder } from '@execonline-inc/decoders';\nimport Decoder from 'jsonous';\nimport { Result } from 'resulty';\n\nconst example: Decoder<string> = jsonParserDecoder(base64Decoder);\nconst result: Result<string, string> = example.decodeAny('ImhlbGxvIg==');\n```\n\n### `pipeD`\n\nThis decoder is used to run two decoders in sequence passing the successfully decoded value from the first as the input for the second.\n\n```ts\nimport { base64Decoder, pipeD, stringLiteral } from '@execonline-inc/decoders';\nimport Decoder from 'jsonous';\nimport { Result } from 'resulty';\n\nconst example: Decoder<'hello'> = pipeD(base64Decoder, stringLiteral('hello'));\nconst result: Result<string, string> = example.decodeAny('aGVsbG8=');\n```\n\n### `numberToStringDecoder`\n\n```ts\nimport { numberToStringDecoder } from '@execonline-inc/decoders';\nimport Decoder from 'jsonous';\nimport { Result } from 'resulty';\n\nconst example: Decoder<string> = numberToStringDecoder;\nconst result: Result<string, string> = example.decodeAny(123);\n```\n\n### `stringToNumberDecoder`\n\n```ts\nimport { stringToNumberDecoder } from '@execonline-inc/decoders';\nimport Decoder from 'jsonous';\nimport { Result } from 'resulty';\n\nconst example: Decoder<number> = stringToNumberDecoder;\nconst result: Result<string, number> = example.decodeAny('123');\n```\n\n### `jsonValueDecoder`\n\nTODO\n\n### `secondsDecoder`\n\n```ts\nimport { secondsDecoder } from '@execonline-inc/decoders';\nimport Decoder from 'jsonous';\nimport { Result } from 'resulty';\n\nconst example: Decoder<Time> = secondsDecoder;\nconst result: Result<string, Time> = example.decodeAny(60);\n```\n\n### `explicitJust`\n\nThis is used to decode a JSON object representing a `Maybe` monad that's expected to be a `Just`:\n\n```ts\nimport { explicitJust } from '@execonline-inc/decoders';\nimport Decoder from 'jsonous';\nimport { Result } from 'resulty';\n\nconst thing = { kind: 'just', value: 123 };\nconst example: Decoder<Maybe<number>> = explicitJust;\nconst result: Result<string, Maybe<number>> = example.decodeAny(thing);\n```\n\n### `explicitNothing`\n\nThis is used to decode a JSON object representing a `Maybe` monad that's expected to be a `Nothing`:\n\n```ts\nimport { explicitNothing } from '@execonline-inc/decoders';\nimport Decoder from 'jsonous';\nimport { Result } from 'resulty';\n\nconst thing = { kind: 'nothing' };\nconst example: Decoder<Maybe<number>> = explicitNothing;\nconst result: Result<string, Maybe<number>> = example.decodeAny(thing);\n```\n\n### `explicitMaybe`\n\nThis is used to decode a JSON object representing a `Maybe` monad that could be either a `Just` or a `Nothing`.\n\n### `mergeObjectDecoders`\n\nThis will produce a single decoder by combining the decoded fields of the two given decoders.\n\nIf the given decoders overlap for any fields, the second decoder will decide the final value for those fields.\n\n```ts\nimport { mergeObjectDecoders, stringLiteral } from '@execonline-inc/decoders';\nimport Decoder, { field } from 'jsonous';\nimport { Result } from 'resulty';\n\ninterface A {\n  foo: string;\n  bar: string;\n}\ninterface B {\n  bar: 'star';\n  baz: 'jazz';\n}\n\nconst objA: A = { foo: 'goo', bar: 'car' };\nconst objB: B = { bar: 'star', baz: 'jazz' };\n\nconst decoderA: Decoder<A> = succeed({})\n  .assign('foo', field('foo', string))\n  .assign('bar', field('bar', string));\nconst decoderB: Decoder<B> = succeed({})\n  .assign('bar', field('bar', stringLiteral('star')))\n  .assign('baz', field('baz', stringLiteral('jazz')));\n\nconst example: Decoder<A & B> = mergeObjectDecoders(decoderA, decoderB);\nconst result: Result<string, A & B> = example.decodeAny({ ...objA, ...objB });\n```\n"}},{"slug":"dom","metadata":{"name":"@execonline-inc/dom","description":"DOM functions"},"markdown":{"content":"# `dom`\n\n> TODO: description\n\n## Usage\n\n```\nconst dom = require('dom');\n\n// TODO: DEMONSTRATE API\n```\n"}},{"slug":"environment","metadata":{"name":"@execonline-inc/environment","description":"Safely read environment cofigurations"},"markdown":{"content":"# `environment`\n\nThe `environment` package provides functions read from the execution environment.\n\n## Types\n\n### `MissingVarError`\n\nResembles the error when the environment variable doesn't exist for a read attempt.\n\n```ts\ninterface MissingVarError {\n  kind: 'missing-var-error';\n  key: string;\n}\n```\n\n### `Production`\n\nInterface representing a production environment.\n\n```ts\ninterface Production {\n  kind: 'production';\n}\n```\n\n### `Development`\n\nInterface representing a development environment.\n\n```ts\ninterface Development {\n  kind: 'development';\n}\n```\n\n### `Unknown`\n\nInterface representing an unknown environment.\n\n```ts\ninterface Unknown {\n  kind: 'unknown';\n}\n```\n\n### `Environment`\n\n```ts\ntype Environment = Production | Development | Unknown;\n```\n\n## Functions\n\n### `missingVarError`\n\nThis function takes an environment variable name and constructs a `MissingVarError` type from it.\n\n```ts\nimport { missingVarError, MissingVarError } from '@execonline-inc/environment';\n\nconst result: MissingVarError = missingVarError('SOME_ENV_VAR');\n// { kind: 'missing-var-error', key: 'SOME_ENV_VAR' }\n```\n\n### `readVarM`\n\nThis function reads for a given key from `process.env` and wraps the value in a `Maybe`. When a value exists for the key, the result is a `Just`, otherwise it is a `Nothing`.\n\n```ts\nimport { readVarM } from '@execonline-inc/environment';\nimport { Maybe } from 'maybeasy';\n\nconst result: Maybe<string> = readVarM('SOME_ENV_VAR');\n```\n\n### `readVarR`\n\nLike `readVarM`, but the condition for no value is an error `Result`.\n\n```ts\nimport { MissingVarError, readVarR } from '@execonline-inc/environment';\nimport { Result } from 'resulty';\n\nconst result: Result<MissingVarError, string> = readVarR('SOME_ENV_VAR');\n```\n\n### `readVarT`\n\nLike `readVarR`, but as a `Task` instead of a `Result`.\n\n```ts\nimport { MissingVarError, readVarT } from '@execonline-inc/environment';\nimport { Task } from 'taskarian';\n\nconst result: Task<MissingVarError, string> = readVarT('SOME_ENV_VAR');\n```\n\n### `environment`\n\nThis function reads the `NODE_ENV` environment variable and returns an object representing the detected environment.\n\n```ts\nimport { environment, Environment } from '@execonline-inc/environment';\n\nconst result: Environment = environment();\n```\n"}},{"slug":"error-handling","metadata":{"name":"@execonline-inc/error-handling","description":"Functions to simplifiy error handling across monad types"},"markdown":{"content":"# `error-handling`\n\nThe `error-handling` package provides several utility functions that allow you to convert between the types Task, Maybe, and Result while handling any errors.\n\n## Functions\n\n### `asTask`\nThe asTask function takes a Result object as input and converts it into a Task object.\n\n```ts\nimport { ok } from 'resulty';\nimport { asTask } from 'error-handling';\n\nconst result = ok('test');\nconst task = asTask(result); // Task\n```\n\n### `asMaybe`\nThe asMaybe function takes a Result object as input and converts it into a Maybe object.\n\n```ts\nimport { ok } from 'resulty';\nimport { asMaybe } from 'error-handling';\n\nconst result = ok('test');\nconst task = asMaybe(result); // Maybe\n```\n\n### `runResult`\nThe runResult function tries to execute the throwable input function, and if it throws an error, it returns an Err case with the error as the value. If the input function runs successfully, it returns an Ok case with the returned value.\n\n```ts\nimport { runResult } from 'error-handling';\n\nconst randomErrorFunction = (): boolean => {\n  if (Math.random() < 0.5) {\n    return true;\n  } else {\n    throw new Error('Random Error!');\n  }\n};\n\nconst result = runResult(randomErrorFunction); // Result\n```\n\n### `runMaybe`\n\nThe runMaybe function tries to execute the throwable input function, and returns a maybe. If an error is thrown `nothing()` will be returned and if the function is successful a `just(value)` will be returned.\n\n```ts\nimport { runMaybe } from 'error-handling';\n\nconst randomErrorFunction = (): boolean => {\n  if (Math.random() < 0.5) {\n    return true;\n  } else {\n    throw new Error('Random Error!');\n  }\n};\n\nconst maybe = runMaybe(randomErrorFunction); // Maybe\n```\n\n### `runTask`\nThe runTask function tries to execute the throwable input function, and if it throws an error, it returns an Err case with the error as the value. If the input function runs successfully, it returns an Ok case with the returned value.\n\n```ts\nimport { runTask } from 'error-handling';\n\nconst randomErrorFunction = (): boolean => {\n  if (Math.random() < 0.5) {\n    return true;\n  } else {\n    throw new Error('Random Error!');\n  }\n};\n\nconst task = runTask(randomErrorFunction); // Task\n```"}},{"slug":"logging","metadata":{"name":"@execonline-inc/logging","description":"Console and warnings and alerting for background logging"},"markdown":{"content":"# `logging`\n\nThe `logging` package provides a few logging functions.\n\n## Functions\n\n### `logger`\n\nThis curried function provides a console logging function with a given prefix.\n\n```ts\nimport { logger } from '@execonline-inc/logging';\n\nconst logger = logger('[EXAMPLE]');\nlogger('abc', 'def');\n// [EXAMPLE] abc def\n```\n\n### `warner`\n\nThis curried function provides a console warning function with a given prefix.\n\n```ts\nimport { warner } from '@execonline-inc/logging';\n\nconst warner = warner('[EXAMPLE]');\nwarner('abc', 'def');\n// [EXAMPLE] abc def\n```\n\n### `log`\n\n_Specific to ExecOnline_\n\nA `logger` with an `[EXO]` prefix.\n\n```ts\nimport { log } from '@execonline-inc/logging';\n\nlog('hello');\n// [EXO] hello\n```\n\n### `logWithTimestamp`\n\nA logger with a timestamp prefix.\n\n```ts\nimport { logWithTimestamp } from '@execonline-inc/logging';\n\nlogWithTimestamp('hello');\n// [2022-05-23T16:34:13.462-04:00] hello\n```\n\n### `warn`\n\n_Specific to ExecOnline_\n\nA `warner` with an `[EXO]` prefix.\n\n```ts\nimport { warn } from '@execonline-inc/logging';\n\nwarn('hello');\n// [EXO] hello\n```\n\n### `warnAndNotify`\n\n_Specific to ExecOnline_\n\nThis function accepts an error name, an error message, and a context object. It sends the message to the console using `warn`, and also uses the provided information to post a notification to the third-party [Honeybadger](https://www.honeybadger.io/) exception monitoring service.\n\n```ts\nimport { warnAndNotify as warnAndNotifyImpl } from '@execonline-inc/logging';\n\nexport const warnAndNotify = warnAndNotifyImpl(Honeybadger.notify);\n\nconst context = { user_id: 123 };\nwarnAndNotify('ErrorName', 'Some error message', context);\n// [EXO] Some error message\n```\n"}},{"slug":"maybe-adapter","metadata":{"name":"@execonline-inc/maybe-adapter","description":"Convert types to and from Maybeasy"},"markdown":{"content":"# `maybe-adapter`\n\nThe `maybe-adapter` package provides functions to convert to/from `Maybe` types.\n\n## Functions\n\n### `toResult`\n\nThis function has a curried and non-curried form. It takes an error and a `Maybe`. When the `Maybe` is a `Just`, a successful `Result` is returned with the wrapped value, otherwise an error `Result` is returned with the given error value.\n\n```ts\nimport { toResult } from '@execonline-inc/maybe-adapter';\nimport { nothing } from 'maybeasy';\n\ntoResult<string, number>('an error message')(nothing());\n```\n\n### `toTask`\n\nThis function has a curried and non-curried form. It takes an error and a `Maybe`. When the `Maybe` is a `Just`, a succeeding `Task` is returned with the wrapped value, otherwise a failing `Task` is returned with the given error value.\n\n```ts\nimport { toTask } from '@execonline-inc/maybe-adapter';\nimport { nothing } from 'maybeasy';\n\ntoTask<string, number>('an error message')(nothing());\n```\n\n### `fromBool`, `when`\n\nThis function has a curried and non-curried form. It wraps a given value in a `Maybe` depending on either the given boolean value or boolean return value of the given function.\n\nAlso, if the first argument is a function, the second argument is passed to that function for evaluation. (See advanced usage example)\n\nAliased as `when`\n\n```ts\nimport { fromBool } from '@execonline-inc/maybe-adapter';\n\nfromBool(true)(123);\nfromBool((): boolean => true)(123);\n// Just<123>\n\n// Advanced usage.\nmapMaybe(when(even), [1, 2, 3, 4]);\n// [2, 4]\n```\n"}},{"slug":"numbers","metadata":{"name":"@execonline-inc/numbers","description":"Type safe number ops"},"markdown":{"content":"# `numbers`\n\nSafely parse numbers from strings\n\n## Functions\n\n### `parseIntM`\n\nAttempts to parse an integer from a string, using `Maybe<number>` to wrap the success or failure of\nthe parse.\n\n```ts\nimport { parseIntM } from '@execonline-inc/numbers';\n\nparseIntM('123').getOrElseValue(0) // returns `123`\nparseIntM('123.42').getOrElseValue(0) // returns `123`\nparseIntM('Hello World!').getOrElseValue(0) // returns `0`\n```\n\n### `parseIntR`\n\nAttempts to parse an integer from a string, using `Result<NumberParseFailure, number>` to wrap the\nsuccess or failure of the parse.\n\n```ts\nimport { parseIntR } from '@execonline-inc/numbers';\n\nparseIntR('123').getOrElseValue(0) // returns `123`\nparseIntR('123.42').getOrElseValue(0) // returns `123`\n\nparseIntR('Hello World').elseDo(console.warn).getOrElseValue(0)\n// Prints object: { kind: 'number-parse-failure', message: `Couldn't parse string into a number` }\n// Returns 0\n```\n\n### `parseIntT`\n\nAttempts to parse an integer from a string, using `Task<NumberParseFailure, number>` to wrap the\nsuccess or failure of the parse.\n\n```ts\nimport { parseIntT } from '@execonline-inc/numbers';\n\nparseIntT('123').fork(() => {}, console.log); // Prints the integer 123\nparseIntT('123.42').fork(() => {}, console.log); // Prints the integer 123\n\nparseIntT('Hello World').fork(console.warn, () => {});\n// Prints object: { kind: 'number-parse-failure', message: `Couldn't parse string into a number` }\n```\n\n### `percentage`\n\nDisplay a number as a percentage.\n\n```ts\nimport { percentage } from '@execonline-inc/numbers';\n\npercentage(42.22) // returns the string \"42%\"\n```\n\n# Numeric Predicates\n\nCompare numbers in a declarative way.\n\n## Functions\n\n### `positive`\n\nCheck if a value is greater than zero.\n\n```ts\nimport { positive } from '@execonline-inc/numbers';\n\npositive(10) // true\npositive(0) // false\n\n```\n\n### `whenPositive`\n\nA function that returns Maybe is available\n\n```ts\nimport { whenPositive } from '@execonline-inc/numbers';\nimport { nothing, just } from 'maybeasy';\n\nconst widgetMessage = (value: Maybe<number>) =>\n  value\n    .andThen(whenPositive)\n    .map((count) => `${count} widgets still remain!`)\n    .getOrElseValue(\"No remaining widgets!\");\n\nwidgetMessage(just(7)) // \"7 widgets still remain!\"\nwidgetMessage(just(0)) // \"No remaining widgets!\"\nwidgetMessage(nothing()) // No remaining widgets!\n```\n\n### `gt`\n\nCheck if a value is greater than.\n\n```ts\nimport { gt } from '@execonline-inc/numbers';\nimport { just, isJust } from 'maybeasy';\n\nconst checkForGreaterThan = (value: number): boolean => just(value).map(gt(10)).isJust();\n\ncheckForGreaterThan(7) // evaluates to false\ncheckForGreaterThan(11) // evaluates to true\n```\n\n### `whenGt`\n\nA function that returns Maybe is available\n\n```ts\nimport { gt, multiplyBy } from '@execonline-inc/numbers';\n\nconst checkForGreaterThanAndMultiply = (value: Maybe<number>) =>\n  value\n    .andThen(whenGt(7))\n    .map(multiplyBy(6))\n    .getOrElseValue(0);\n\ncheckForGreaterThanAndMultiply(4) // evaluates to 0\ncheckForGreaterThanAndMultiply(11) // evaluates to 66\n```\n\n## Other Functions\n\nThe following functions work similarly. Many are available with versions that return Maybe.\n\n### `lt`\nLess than\n### `gte`\nGreater than or equal to\n### `lte`\nLess than or equal to\n### `eq`\nEqual to\n### `neq`\nNot equal to\n### `between`\nTakes a min and max as arguments, returns a boolean.\n### `betweenEq`\nTakes a min and max as arguments, returns a boolean.\n### `even`\nValue is even\n### `odd`\nValue is odd\n### `positive`\nValue is positive\n### `negative`\nValue is negative\n### `zero`\nValue is zero\n### `multiplyBy`\nMultiplies the value by inputted value\n### `divideBy`\nDivides the value by inputted value\n### `add`\nAdds the value to inputted value\n### `subtractBy`\nSubtracts the value from inputted value\n\n"}},{"slug":"resource","metadata":{"name":"@execonline-inc/resource","description":"Models JSON api resources "},"markdown":{"content":"# `resource`\n\nThe `resource` package provides types and functions for dealing with HATEOAS REST resources.\n\n## Usage\n\nCreate a module dedicated to resources and export as necessary.\n\n```ts\nimport {\n  Link as LinkR,\n  payload as payloadR,\n  Resource as ResourceR,\n  resource as resourceR,\n  ResourceWithErrors as ResourceWithErrorsR,\n  ResourceWithMetadata as ResourceWithMetadataR,\n} from '@execonline-inc/resource';\nimport { Result } from 'resulty';\n\nconst rels = ['prev', 'next', 'self'] as const;\n\nexport type Rel = typeof rels[number];\n\nexport const toRel = (value: string): Result<string, Rel> =>\n  toResult(\n    `Expected to find an HTTP rel string. Instead I found ${value}`,\n    find(rel => rel === value, rels)\n  );\n\nexport type Link = LinkR<Rel>;\nexport type Resource<T> = ResourceR<T, Rel>;\nexport type ResourceWithErrors<T> = ResourceWithErrorsR<T, Rel>;\nexport type ResourceWithMetadata<T, M> = ResourceWithMetadataR<T, M, Rel>;\n\nexport const resource: <T>(links: ReadonlyArray<Link>, payload: T) => Resource<T> = resourceR;\nexport const payload: <T, R extends Resource<T>>(r: R) => T = payloadR;\n```\n\n## Types\n\n### `ResourceCollection`\n\n```ts\nimport { Empty, None, Results } from '@execonline-inc/resource';\n\ntype ResourceCollection<T, Rel extends string> = None | Empty | Results<T, Rel>;\n```\n\n### `None`\n\n```ts\ninterface None {\n  kind: 'none';\n}\n```\n\n### `Empty`\n\n```ts\ninterface Empty {\n  kind: 'empty';\n}\n```\n\n### `Results`\n\n```ts\nimport { Resource } from '@execonline-inc/resource';\n\ninterface Results<T, Rel extends string> {\n  kind: 'results';\n  results: Resource<T[], Rel>;\n}\n```\n\n### `Link`\n\n```ts\nimport { Method } from 'ajaxian';\n\ninterface Link<Rel extends string> {\n  rel: Rel;\n  href: string;\n  method: Method;\n  type: string;\n}\n```\n\n### `ServerError`\n\n```ts\ninterface ServerError {\n  type: string;\n  param: string;\n  message: string;\n  code: string;\n  source: string;\n}\n```\n\n### `Linkable`\n\n```ts\nimport { Link } from '@execonline-inc/resource';\n\ninterface Linkable<Rel extends string> {\n  links: ReadonlyArray<Link<Rel>>;\n}\n```\n\n### `PossiblyLinkable`\n\n```ts\nimport { Linkable } from '@execonline-inc/resource';\n\ninterface PossiblyLinkable<Rel extends string> {\n  whenLinks: Maybe<Linkable<Rel>>;\n}\n```\n\n### `Payloaded`\n\n```ts\ninterface Payloaded<T> {\n  payload: T;\n}\n```\n\n### `Resource`\n\n```ts\nimport { Linkable, Payloaded } from '@execonline-inc/resource';\n\ninterface Resource<T, Rel extends string> extends Payloaded<T>, Linkable<Rel> {}\n```\n\n### `ResourceWithErrors`\n\n```ts\nimport { Resource, ServerError } from '@execonline-inc/resource';\n\ninterface ResourceWithErrors<T, Rel extends string> extends Resource<T, Rel> {\n  errors: ServerError[];\n}\n```\n\n### `IdentifiablePayload`\n\n```ts\ninterface IdentifiablePayload {\n  id: number;\n}\n```\n\n### `ResourceWithMetadata`\n\n```ts\nimport { Resource } from '@execonline-inc/resource';\n\ninterface ResourceWithMetadata<T, M, Rel extends string> extends Resource<T, Rel> {\n  metadata: M;\n}\n```\n\n### `ValidationError`\n\n```ts\ninterface ValidationError {\n  kind: 'validation-error';\n  on: string;\n  param: string;\n  error: string;\n  detail: string;\n}\n```\n\n### `ValidationErrors`\n\n```ts\nimport { ValidationError } from '@execonline-inc/resource';\n\ntype ValidationErrors = ValidationError[];\n```\n\n### `PaginationMetadata`\n\n```ts\ninterface PaginationMetadata {\n  resultsCount: number;\n  pageCount: number;\n  perPage: number;\n  currentPage: number;\n}\n```\n\n## Functions\n\n### `none`\n\nCreates a `None` object.\n\n```ts\nimport { none, ResourceCollection } from '@execonline-inc/resource';\n\nconst result: ResourceCollection<unknown, 'self'> = none();\n```\n\n### `empty`\n\nCreates an `Empty` object.\n\n```ts\nimport { empty, ResourceCollection } from '@execonline-inc/resource';\n\nconst result: ResourceCollection<unknown, 'self'> = empty();\n```\n\n### `results`\n\nCreates a `Results` object.\n\n```ts\nimport { Link, results, Resource, ResourceCollection } from '@execonline-inc/resource';\n\ninterface ExamplePayload {\n  kind: 'example-payload';\n}\nconst payload = { kind: 'example-payload' };\nconst links: ReadonlyArray<Link<'self'>> = [\n  {\n    rel: 'self',\n    href: 'https://example.com/',\n    method: 'get',\n    type: 'application/json',\n  },\n];\nconst resource: Resource<ExamplePayload[], 'self'> = { payload: [payload], links };\nconst result: ResourceCollection<ExamplePayload, 'self'> = results(resource);\n```\n\n### `resources`\n\nThis function returns the appropriate `ResourceCollection` type depending on the presence of the given resource and its payload.\n\n```ts\nimport { Link, resources, Resource, ResourceCollection } from '@execonline-inc/resource';\nimport { just } from 'maybeasy';\n\ninterface ExamplePayload {\n  kind: 'example-payload';\n}\nconst payload = { kind: 'example-payload' };\nconst links: ReadonlyArray<Link<'self'>> = [\n  {\n    rel: 'self',\n    href: 'https://example.com/',\n    method: 'get',\n    type: 'application/json',\n  },\n];\nconst resource: Resource<ExamplePayload[], 'self'> = { payload: [payload], links };\nconst result: ResourceCollection<ExamplePayload, 'self'> = resources(just(resource));\n```\n\n### `linksDecoder`\n\nThis function returns a decoder for decoding HATEOAS links with valid `rel` values. It takes a function that checks for valid `rel` values.\n\n```ts\nimport { find } from '@execonline-inc/collections';\nimport { toResult } from '@execonline-inc/maybe-adapter';\nimport { Link, linksDecoder } from '@execonline-inc/resource';\nimport { Result } from 'resulty';\n\nconst validRels = ['self'] as const;\ntype Rel = typeof validRels[number];\nconst toRel = (v: string): Result<string, Rel> =>\n  toResult(\n    `Invalid rel found: ${v}`,\n    find(rel => rel === v, validRels)\n  );\nconst linksDecoder: Decoder<ReadonlyArray<Link<Rel>>> = linksDecoder<Rel>(toRel);\n```\n\n### `errorDecoder`\n\nThis decoder is for a particular error object structure.\n\n```ts\nimport { errorDecoder, ServerError } from '@execonline-inc/resource';\n\nconst obj = {\n  type: 'some type',\n  param: 'some param',\n  code: '123',\n  source: 'some source',\n  message: 'some message',\n};\nconst decoder: Decoder<ServerError> = errorDecoder;\nconst result: Result<string, ServerError> = decoder.decodeAny(obj);\n```\n\n### `resourceDecoder`\n\nThis function with a curried and non-curried form. The returned decoder is for a HATEOAS resource structure.\n\n```ts\nimport { find } from '@execonline-inc/collections';\nimport { resourceDecoder, Resource } from '@execonline-inc/resource';\nimport { toResult } from '@execonline-inc/maybe-adapter';\nimport { Result } from 'resulty';\n\ntype Rel = 'self';\ninterface ExamplePayload {}\nconst obj = { payload: {}, links: [] };\n\nconst toRel = (v: string): Result<string, Rel> =>\n  toResult(\n    `Invalid rel found: ${v}`,\n    find(rel => rel === v, validRels)\n  );\n\nconst payloadDecoder: Decoder<ExamplePayload> = succeed({});\nconst decoder: Decoder<Resource<ExamplePayload, Rel>> = resourceDecoder<ExamplePayload, Rel>(toRel)(\n  payloadDecoder\n);\nconst result: Result<string, Resource<ExamplePayload, Rel>> = decoder.decodeAny(obj);\n```\n\n### `resourceWithMetadataDecoder`\n\nThis curried function returns a decoder for a resource with an additional `metadata` key.\n\n```ts\nimport { find } from '@execonline-inc/collections';\nimport { resourceWithMetadataDecoder, ResourceWithMetadata } from '@execonline-inc/resource';\nimport { toResult } from '@execonline-inc/maybe-adapter';\nimport Decoder, { succeed } from 'jsonous';\nimport { Result } from 'resulty';\n\ntype Rel = 'self';\ninterface ExamplePayload {}\ninterface ExampleMetadata {}\n\nconst obj = {\n  payload: {},\n  links: [],\n  metadata: {},\n};\nconst toRel = (v: string): Result<string, Rel> =>\n  toResult(\n    `Invalid rel found: ${v}`,\n    find(rel => rel === v, validRels)\n  );\n\nconst payloadDecoder: Decoder<ExamplePayload> = succeed({});\nconst metadataDecoder: Decoder<ExampleMetadata> = succeed({});\nconst decoder: Decoder<ResourceWithMetadata<\n  ExamplePayload,\n  ExampleMetadata,\n  Rel\n>> = resourceWithMetadataDecoder<ExamplePayload, ExampleMetadata, Rel>(toRel)(\n  payloadDecoder,\n  metadataDecoder\n);\nconst result: Result<\n  string,\n  ResourceWithMetadata<ExamplePayload, ExampleMetadata, Rel>\n> = decoder.decodeAny(obj);\n```\n\n### `resourceWithErrorsDecoder`\n\nThis curried function returns a decoder for a resource with an additional `errors` key.\n\n```ts\nimport { find } from '@execonline-inc/collections';\nimport { resourceWithErrorsDecoder, ResourceWithErrors } from '@execonline-inc/resource';\nimport { toResult } from '@execonline-inc/maybe-adapter';\nimport Decoder, { succeed } from 'jsonous';\nimport { Result } from 'resulty';\n\ntype Rel = 'self';\ninterface ExamplePayload {}\n\nconst obj = {\n  payload: {},\n  links: [],\n  errors: [],\n};\nconst toRel = (v: string): Result<string, Rel> =>\n  toResult(\n    `Invalid rel found: ${v}`,\n    find(rel => rel === v, validRels)\n  );\n\nconst payloadDecoder: Decoder<ExamplePayload> = succeed({});\nconst decoder: Decoder<ResourceWithErrors<ExamplePayload, Rel>> = resourceWithErrorsDecoder<\n  ExamplePayload,\n  Rel\n>(toRel)(payloadDecoder, metadataDecoder);\nconst result: Result<string, ResourceWithErrors<ExamplePayload, Rel>> = decoder.decodeAny(obj);\n```\n\n### `paginationMetadataDecoder`\n\nThis decoder decodes a specific pagination object structure.\n\n```ts\nimport { paginationMetadataDecoder, PaginationMetadata } from '@execonline-inc/resource';\nimport { Result } from 'resulty';\n\nconst obj = { results_count: 1, page_count: 1, per_page: 1, current_page: 1 };\nconst result: Result<string, PaginationMetadata> = paginationMetadataDecoder.decodeAny(obj);\n```\n\n### `validationErrorDecoder`\n\nThis decoder decodes a specific validation error object structure.\n\n```ts\nimport { validationErrorDecoder, ValidationError } from '@execonline-inc/resource';\nimport { Result } from 'resulty';\n\nconst obj = {\n  kind: 'validation-error',\n  on: 'that',\n  param: 'that',\n  error: 'error',\n  detail: 'detail',\n};\nconst result: Result<string, ValidationError> = validationErrorDecoder.decodeAny(obj);\n```\n\n### `validationErrorsDecoder`\n\nThis decoder is for decoding an array with `validationErrorDecoder`.\n\n### `selfUrl`\n\nThis function finds the link in a resource with a `rel` of `self`.\n\n```ts\nimport { Resource, selfUrl } from '@execonline-inc/resource';\nimport { Maybe } from 'maybeasy';\n\ntype Rel = 'self';\ninterface ExamplePayload {}\n\nconst resource: Resource<ExamplePaylod, Rel> = {\n  payload: {},\n  links: [\n    {\n      rel: 'self',\n      href: 'https://example.com/',\n      method: 'get',\n      type: 'application/json',\n    },\n  ],\n};\nconst result: Maybe<Link<Rel>> = selfUrl<ExamplePayload, Rel>(resource);\n```\n\n### `iconUrl`\n\nThis function finds the link in a resource with a `rel` of `icon`.\n\n```ts\nimport { iconUrl, Resource } from '@execonline-inc/resource';\nimport { Maybe } from 'maybeasy';\n\ntype Rel = 'icon';\ninterface ExamplePayload {}\n\nconst resource: Resource<ExamplePaylod, Rel> = {\n  payload: {},\n  links: [\n    {\n      rel: 'icon',\n      href: 'https://example.com/',\n      method: 'get',\n      type: 'application/json',\n    },\n  ],\n};\nconst result: Maybe<Link<Rel>> = iconUrl<ExamplePayload, Rel>(resource);\n```\n\n### `isNotSelf`\n\nThis curried function determines if the given URL is not the same as the link in the resource with a rel of `self`.\n\n```ts\nimport { isNotSelf, Resource } from '@execonline-inc/resource';\n\ntype Rel = 'self';\ninterface ExamplePayload {}\n\nconst resource: Resource<ExamplePaylod, Rel> = {\n  payload: {},\n  links: [\n    {\n      rel: 'self',\n      href: 'https://example.com/',\n      method: 'get',\n      type: 'application/json',\n    },\n  ],\n};\nconst result: boolean = isNotSelf('https://not.example.com/')(resource);\n```\n\n### `resource`\n\nThis function constructs a resource object given separated links and a payload.\n\n```ts\nimport { Link, resource, Resource } from '@execonline-inc/resource';\n\ntype Rel = 'self';\ninterface ExamplePayload {}\n\nconst links: ReadonlyArray<Link<Rel>> = [];\nconst payload: ExamplePayload = {};\nconst result: Resource<ExamplePayload, Rel> = resource<Rel, ExamplePayload>(links, payload);\n```\n\n### `payload`\n\nThis function retrieves the payload from a given resource.\n\n```ts\nimport { payload, Resource } from '@execonline-inc/resource';\n\ntype Rel = 'self';\ninterface ExamplePayload {}\n\nconst resource: Resource<ExamplePayload, Rel> = { payload: {}, links: [] };\nconst result: ExamplePayload = payload(resource);\n```\n\n### `links`\n\nThis function retrieves the links from a given resource.\n\n```ts\nimport { links, Link, Resource } from '@execonline-inc/resource';\n\ntype Rel = 'self';\ninterface ExamplePayload {}\n\nconst resource: Resource<ExamplePayload, Rel> = { payload: {}, links: [] };\nconst result: ReadonlyArray<Link<Rel>> = links(resource);\n```\n"}},{"slug":"strings","metadata":{"name":"@execonline-inc/strings","description":"Functions for manipulating strings"},"markdown":{"content":"# `strings`\n\n> TODO: description\n\n## Usage\n\n```\nconst strings = require('strings');\n\n// TODO: DEMONSTRATE API\n```\n"}},{"slug":"time","metadata":{"name":"@execonline-inc/time","description":"Time types for interacting with JavaScript"},"markdown":{"content":"# `time`\n\nThe `time` package provides interfaces and functions for dealing with time durations.\n\n```ts\nimport * as time from '@execonline-inc/time';\n```\n\n## Types\n\n### `Milliseconds`\n\n```ts\ninterface Milliseconds {\n  kind: 'milliseconds';\n  milliseconds: number;\n}\n```\n\n### `Seconds`\n\n```ts\ninterface Seconds {\n  kind: 'seconds';\n  seconds: number;\n}\n```\n\n### `Minutes`\n\n```ts\ninterface Minutes {\n  kind: 'minutes';\n  minutes: number;\n}\n```\n\n### `Hours`\n\n```ts\ninterface Hours {\n  kind: 'hours';\n  hours: number;\n}\n```\n\n### `Days`\n\n```ts\ninterface Days {\n  kind: 'days';\n  days: number;\n}\n```\n\n### `Time`\n\n```ts\nimport { Days, Hours, Milliseconds, Minutes, Seconds } from '@execonline-inc/time';\n\ntype Time = Days | Hours | Minutes | Seconds | Milliseconds;\n```\n\n## Functions\n\n### `milliseconds`, `seconds`, `minutes`, `hours`, `days`\n\nThese functions accept a `number` and construct an object of the corresponding type with that quantity.\n\n```ts\nimport * as time from '@execonline-inc/time';\n\nconst milliseconds: time.Milliseconds = time.milliseconds(86400000);\nconst seconds: time.Seconds = time.seconds(86400);\nconst minutes: time.Minutes = time.minutes(1440);\nconst hours: time.Hours = time.hours(24);\nconst days: time.Days = time.days(1);\n```\n\n### `toMilliseconds`, `toSeconds`, `toMinutes`, `toHours`, `toDays`\n\nThese functions accept a `Time` and convert the quantity of that type to the type that their name states.\n\n```ts\nimport * as time from '@execonline-inc/time';\n\nconst milliseconds: time.Milliseconds = time.toMilliseconds(time.minutes(3));\nconst seconds: time.Seconds = time.toSeconds(time.hours(3));\nconst minutes: time.Minutes = time.toMinutes(time.days(2));\nconst hours: time.Hours = time.toHours(time.milliseconds(1000));\nconst days: time.Days = time.toDays(time.seconds(200));\n```\n\n### `toJS`\n\nThis function takes a `Time` and returns the equivalent millisecond count as a `number`.\n\n```ts\nimport { minutes, toJS } from '@execonline-inc/time';\n\nconst millisecondCount: number = toJS(minutes(1));\n```\n"}},{"slug":"time-distance","metadata":{"name":"@execonline-inc/time-distance","description":"Computes differences between times and dates"},"markdown":{"content":"# `time-distance`\n\nThe `time-distance` package provides interfaces and functions for dealing with distances between dates.\n\n```ts\nimport * as time from '@execonline-inc/time-distance';\n```\n\n## Types\n\n### `Future`\n\n```ts\ninterface Future {\n  kind: 'future';\n  gap: Time;\n}\n```\n\n### `Now`\n\n```ts\ninterface Now {\n  kind: 'now';\n}\n```\n\n### `TimeDistance`\n\n```ts\ninterface Past {\n  kind: 'past';\n  gap: Time;\n}\n```\n\n### `Past`\n\n```ts\ntype TimeVector = Future | Now | Past;\n```\n\n### `EffectivelyNow`\n\n```ts\ninterface EffectivelyNow {\n  kind: 'effectively-now';\n  time: Time;\n}\n```\n\n## Functions\n\n### `distanceFrom`\n\nThis function computes the gap between two Times. If the first Time is\nlarger then the second, than the result is considered to be in the\nfuture. A smaller first number is considered to be in the past. And\nequal times are considered now.\n\n```ts\nimport { distanceFrom } from '@execonline-inc/time-distance';\nimport { Time, seconds } from '@execonline-inc/time';\n\nconst time1: Time = seconds(10);\nconst time2: Time = seconds(20);\ndistanceFrom(time1, time2); // --> Past { ... }\n```\n\n### `distanceFromDate`\n\nThis function computes the Time distance between two dates. Be aware\nthat Date objects in Javascript can be invalid.\n\n```ts\nimport { distanceFromDate } from '@execonline-inc/time-distance';\n\nconst future = distanceFromDate(new Date(1), new Date());\nconst badDates = distanceFromDate(new Date('foo'), new Date());\n```\n\n### `toLargestMeaningfulUnit`\n\nThis function converts a TimeDistance so that the gap is expressed in\nterms of the largest meaningful time unit. Using this function may\ncause a loss of precision on the time gap.\n\n```ts\nconst distance: TimeVector = distanceBetween(minutes(15), minutes(25));\ntoLargestMeaningfulUnit(distance);\n```\n\n### `largestMeaningfulUnit`\n\nThis function takes a Time and returns a new Time that represents\nthat largest meaningful unit of time. For example, `seconds(60)` would\nbe converted to `minutes(1)`, since that is the largest unit of time\nthat isn't effectively zero.\n\nNote that \"meaningful\" here means meaningful to human beings. Anything\nless than a second is treated as EffectivelyNow\n\n```ts\nconst result: Ok<Time> = largestMeaningfulUnit(seconds(60));\nconst nowish: Err<EffectivelyNow> = largestMeaningfulUnit(milliseconds(100));\n```\n"}},{"slug":"translations","metadata":{"name":"@execonline-inc/translations","description":"Support for typed and interpolatable translations"},"markdown":{"content":"# `translations`\n\nThe `translations` package provides a library for support of typed translation keys and typed React-based translation interpolation.\n\n## Usage\n\nThis library uses the [i18next](https://www.i18next.com/) library underneath a custom adapter. The i18next library handles translating, pluralizing, and basic interpolation (using `{{abc}}` placeholders).\n\nThe custom adapter implementation handles type-checking and component interpolation (using `<abc/>` and `<abc>...</abc>` placeholders).\n\nAll translation content must be added to the translation files whose location is specified with the `loadPath` configuration which is passed to i18next.\n\nSee the `translations` function for integrating the library into an application. Create a translations module in the application and export the relevant things.\n\n## Types\n\n## Components\n\n### `AlreadyTranslated`\n\nThis component represents content that has already been translated (such as pre-translated content from a backend). Its use in a component tree helps to distinguish content that has been addressed for translation with content that has not.\n\n```tsx\nimport { AlreadyTranslated, AlreadyTranslatedText } from '@execonline-inc/translations';\n\nconst text: AlreadyTranslatedText = { kind: 'already-translated-text', text: 'content' };\nconst component = <AlreadyTranslated content={text} />;\n```\n\n### `L`\n\nThis component will localize a date/time according to a given format.\n\n```ts\nimport { LocalizationFormat, Localizeable, translations } from '@execonline-inc/translations';\nconst { L } = translations<...>(...) // see `translations` documentation\n\nconst localizeable: Localizeable = new Date();\nconst format: LocalizationFormat = 'long-date-and-time';\n\nconst component = <L localizeable={localizeable} format={format} />;\n```\n\n### `T`\n\nThis component performs all available translation features given a typed translation definition via its props.\n\n```tsx\nimport { translations } from '@execonline-inc/translations';\nconst { T } = translations<...>(...) // see `translations` documentation\n\nconst component = <T kind=\"something to translate\" />;\n```\n\n### `NotTranslated`\n\nSome content is not suitable for translation. Some examples of this are:\n\n- proper names (though there may be cases where they can be represented in the target language)\n- email addresses\n- URLs\n\nRendering this type of content directly in component trees may be confused with content that hasn't been addressed for translation yet, so wrapping it in this component makes it clear that it has been considered for translation.\n\n```tsx\nimport { NotTranslated } from '@execonline-inc/translations';\n\nconst text: string = 'not translatable';\nconst component = <NotTranslated text={text} />;\n```\n\n### `TranslationsContext`\n\nThis component is an implementation of a [React Context](https://reactjs.org/docs/context.html) whose data is a `TranslationsState`.\n\n```tsx\nimport { TranslationsContext, TranslationsState } from '@execonline-inc/translations';\n\nconst state: TranslationsState = { kind: 'uninitialized' };\nconst consumer = (ts: TranslationsState): React.ReactNode => <>{ts.kind}</>;\n\nconst Example: React.FC = () => (\n  <TranslationsContext.Provider value={state}>\n    <TranslationsContext.Consumer>{consumer}</TranslationsContext.Consumer>\n  </TranslationsContext.Provider>\n);\n```\n\n### `TranslationsLoader`\n\nThis component loads the the translations when it is mounted and wraps its children in a `TranslationsContext.Provider`. It renders the component passed as the `loading` prop until the translations are loaded to prevent the normal child components from rendering without content (because it's awaiting translation) and eventually appearing suddenly.\n\n```tsx\nimport { translations, TranslationsLoader } from '@execonline-inc/translations';\nconst { loader } = translations<...>(...) // see `translations` documentation\n\nconst component = <TranslationsLoader loader={loader} loading={<></>} />;\n```\n\n## Functions\n\n### `alreadyTranslatedText`\n\nThis decoder decodes to an `AlreadyTranslatedText` object from a string.\n\n```ts\nimport { alreadyTranslatedText, AlreadyTranslatedText } from '@execonline-inc/translations';\n\nconst decoder: Decoder<AlreadyTranslatedText> = alreadyTranslatedText;\nconst result: Result<string, AlreadyTranslatedText> = decoder.decodeAny('content');\n```\n\n### `defaultSettings`\n\nThese are default settings for `i18next` based on ExecOnline's use of the library.\n\n### `initTask`\n\nThis function will return a `Task` to initialize `i18next`. It provides the opportunity for `i18next` to be configured as necessary by the user of this library.\n\n```tsx\nimport { initTask, TranslationsLoader } from '@execonline-inc/translations';\nimport i18next from 'i18next';\nimport LanguageDetector from 'i18next-browser-languagedetector';\nimport HttpApi from 'i18next-http-backend';\n\nconst i18nextSettings = {\n  /* ... */\n};\n\nconst i18nextWithModules = i18next.use(HttpApi).use(LanguageDetector);\n\nconst loader = initTask(i18nextWithModules, i18nextSettings);\n\n<TranslationsLoader loader={loader} loading={<></>} />;\n```\n\n### `localization`\n\nThis function will localize a date/time for a given language and according to a given format.\n\n```ts\nimport { localization, LocalizationFormat, Localizeable } from '@execonline-inc/translations';\n\nconst localizeable: Localizeable = new Date();\nconst format: LocalizationFormat = 'long-date-and-time';\nconst language = 'en-US';\n\nconst result = localization(localizeable, format, language);\n```\n\n### `localizer`\n\nThis curried function will localize a date/time according to a given format under certain translation mapping load states.\n\nWhen the state is `loaded` or `loaded-from-fallback`, localization occurs via a call to `localization`.\n\nWhen the state is `uninitialized`, the localizeable argument is converted to a string.\n\n```ts\nimport {\n  localizer,\n  LocalizationFormat,\n  Localizeable,\n  TranslationsState,\n} from '@execonline-inc/translations';\n\nconst localizeable: Localizeable = new Date();\nconst format: LocalizationFormat = 'long-date-and-time';\nconst state: TranslationsState = { kind: 'uninitialized' };\n\nconst result: string = localizer(localizeable, format)(state);\n```\n\n### `translation`\n\nThis curried function performs the lookup in the translation mapping file and simple interpolation when appropriate based on the text to be translated and the state of the mapping.\n\nWhen the state is `loaded` or `loaded-from-fallback`, the mapped translation text is returned. If the text is found to be \"not translatable\", then it is returned without translation.\n\nWhen the state is `uninitialized`, an empty string is returned.\n\n```ts\nimport { translations, TranslationsState } from '@execonline-inc/translations';\nconst { translation } = translations<...>(...) // see `translations` documentation\n\nconst state: TranslationsState = { kind: 'uninitialized' };\nconst result: string = translation('something to translate', {})(state);\n```\n\n### `translator`\n\nThis curried function performs all available translation features given a typed translation definition and the mapping load state.\n\n```ts\nimport { translations, TranslationsState } from '@execonline-inc/translations';\nconst { translator } = translations<...>(...) // see `translations` documentation\n\nconst state: TranslationsState = { kind: 'uninitialized' };\nconst result: React.ReactNode = translator({ kind: 'something to translate' })(state);\n```\n\n### `translations`\n\nThis function returns an object of functions and components that are typed according to the translation types provided to the `translations` function.\n\n```ts\nimport {\n  Config,\n  translations,\n  interpolator,\n  Interpolator,\n  parameterized,\n  Parameterized,\n  ParameterizedFn,\n  scalar,\n} from '@execonline-inc/translations';\nimport i18next, * as i18n from 'i18next';\nimport LanguageDetector from 'i18next-browser-languagedetector';\n\nconst loader = initTask(i18next.use(LanguageDetector), {\n  ...defaultSettings,\n  backend: {\n    loadPath: 'public/locales/{{lng}}/{{ns}}.json',\n  },\n});\n\nconst translatablePlainTextKeys = ['something to translate', 'something else'] as const;\nconst notTranslatable = ['email@example.com', 'https://example.com/'] as const;\n\ntype TranslatablePlainTextKey = typeof translatablePlainTextKeys[number];\ntype NotTranslatable = typeof notTranslatable[number];\ntype ParameterizedProps =\n  | { kind: '{{count}} minutes'; count: number }\n  | { kind: '<bolded>So</bolded> cool!'; bolded: Interpolator };\n\ntype PlainTextKey = TranslatablePlainTextKey | NotTranslatable;\ntype ParameterizedKey = ParameterizedProps['kind'];\n\nconst parameterizedValues: ParameterizedFn<ParameterizedKey, ParameterizedProps> = (\n  props: ParameterizedProps\n): Parameterized<ParameterizedKey, ParameterizedProps> => {\n  switch (props.kind) {\n    case '{{count}} minutes':\n      return parameterized(props, { count: scalar(props.count) });\n    case '<bolded>So</bolded> cool!':\n      return parameterized(props, { bolded: interpolator(props.bolded) });\n  }\n};\n\nconst { L, translation, translator, T } = translations<\n  PlainTextKey,\n  NotTranslatable,\n  ParameterizedKey,\n  ParameterizedProps\n>(translatablePlainTextKeys, notTranslatable, parameterizedValues);\n```\n"}},{"slug":"url","metadata":{"name":"@execonline-inc/url","description":"Safe URL parsing"},"markdown":{"content":"# `url`\n\nThe `url` package provides functions to validate URLs.\n\n## Types\n\n### `InvalidUrlError`\n\n```ts\ninterface InvalidUrlError {\n  kind: 'invalid-url-error';\n  href: string;\n  base?: string | URL;\n  error: unknown;\n}\n```\n\n## Functions\n\n### `invalidUrlError`\n\nThis function constructs an `InvalidUrlError` object from the given parameters.\n\n```ts\nimport { invalidUrlError, InvalidUrlError } from '@execonline-inc/url';\n\nconst error: unknown = {};\nconst href: string = 'href';\nconst base: string = 'base';\nconst result: InvalidUrlError = invalidUrlError(error, href, base);\n```\n\n### `toUrlR`\n\nThis function attempts construction of a `URL` object and returns a `Result`. Handles a related [bug in Safari](https://github.com/zloirock/core-js/issues/656).\n\n```ts\nimport { InvalidUrlError, toUrlR } from '@execonline-inc/url';\nimport { Result } from 'resulty';\n\nconst result: Result<InvalidUrlError, URL> = toUrlR('href', 'base');\n```\n\n### `toUrl`\n\nThis function attempts construction of a `URL` object (via `toUrlR`) and returns a `Maybe`.\n\n```ts\nimport { InvalidUrlError, toUrl } from '@execonline-inc/url';\nimport { Maybe } from 'maybeasy';\n\nconst result: Maybe<InvalidUrlError> = toUrl('href', 'base');\n```\n\n### `toUrlT`\n\nThis function attempts construction of a `URL` object (via `toUrlR`) as a `Task`.\n\n```ts\nimport { InvalidUrlError, toUrlT } from '@execonline-inc/url';\nimport { Task } from 'taskarian';\n\nconst result: Task<InvalidUrlError, URL> = toUrlT('href', 'base');\n```\n"}},{"slug":"web-url","metadata":{"name":"@execonline-inc/web-url","description":"Browser API safe URL parsing"},"markdown":{"content":"# web-url\n\n`web-url` provides services for validating and constructing URLs.\n\nIt is a wrapper around the [URL](https://developer.mozilla.org/en-US/docs/Web/API/URL)\nand [URLSearchParams](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams) API.\n\n## Types\n\n### `InvalidWebUrlError`\n\n```ts\ninterface InvalidWebUrlError {\n  kind: 'invalid-web-url-error';\n  error: unknown;\n}\n```\n\n## Functions\n\n### `invalidWebUrlError`\n\nThis function constructs an `InvalidWebUrlError` object from the given parameters.\n\n```ts\nimport { InvalidWebUrlError } from '@execonline-inc/web-url';\n\nconst error: unknown = {};\nconst result: InvalidWebUrlError = invalidWebUrlError(error);\n```\n\n### `href`\n\nThis function returns the `href` of the `URL` object.\n\n```ts\nimport { href, toUrl } from '@execonline-inc/web-url';\ntoUrl(\"https://example.com\").map(href) // Just(\"https://example.com\")\n```\n\n### `toUrlR`\n\nThis function attempts construction of a `URL` object and returns a `Result`. Handles a related [bug in Safari](https://github.com/zloirock/core-js/issues/656).\n\n```ts\nimport { InvalidWebUrlError, toUrlR } from '@execonline-inc/web-url';\nimport { Result } from 'resulty';\n\ntoUrlR('foo', 'http://example.com').map((url: URL) => url.href) // Ok(\"http://example.com/foo\")\n\nconst result: Result<InvalidWebUrlError, URL> = toUrlR('href', 'base');\n```\n\n### `toUrl`\n\nThis function attempts construction of a `URL` object (via `toUrlR`) and returns a `Maybe`.\n\n```ts\nimport { InvalidWebUrlError, toUrl } from '@execonline-inc/web-url';\nimport { Maybe } from 'maybeasy';\n\ntoUrl('foo', 'http://example.com').map((url: URL) => url.href) // Just(\"http://example.com/foo\")\n```\n\n### `toUrlT`\n\nThis function attempts construction of a `URL` object (via `toUrlR`) as a `Task`.\n\n```ts\nimport { InvalidWebUrlError, toUrlT } from '@execonline-inc/web-url';\nimport Task from 'taskarian';\n\ntoUrlT('foo', 'http://example.com').fork(\n  (error: InvalidWebUrlError) => console.error(error),\n  (url: URL) => console.log(url.href) // $> \"http://example.com/foo\"\n);\n```\n\n### `getQueryParam`\n\nThis function returns the first value of the query parameter with the given name.\n\n```ts\nimport { getQueryParam, toUrl } from '@execonline-inc/web-url';\ntoUrl(\"https://example.com?foo=bar&foo=baz\").andThen(getQueryParam(\"foo\")) // Just(\"bar\")\n```\n\n### `getQueryParamArray`\n\nThis function returns all values in a query parameter with the given name.\n\n```ts\nimport { getQueryParamArray, toUrl } from '@execonline-inc/web-url';\ntoUrl(\"https://example.com?foo=bar&foo=baz\").map(getQueryParamArray(\"foo\")) // Just([\"bar\", \"baz\"])\n```\n\n### `getQueryParamRailsArray`\n\nThis function returns all values in a query parameter with the given name, Rails-style.\n\n```ts\nimport { getQueryParamRailsArray, toUrl } from '@execonline-inc/web-url';\ntoUrl(\"https://example.com?foo[]=bar&foo[]=baz\").map(getQueryParamRailsArray(\"foo\")) // Just([\"bar\", \"baz\"])\n```\n\n\n### `putQueryParam`\n\nThis function adds a query parameter with the given name and value to the URL.\n\n```ts\nimport { putQueryParam, toUrl, href } from '@execonline-inc/web-url';\ntoUrl(\"https://example.com\").map(putQueryParam(\"foo\", \"bar\")).map(href) // Just(\"https://example.com?foo=bar\")\n```\n\n### `putQueryParamArray`\n\nThis function adds a query parameter with the given name and values to the URL.\n\n```ts\nimport { putQueryParamArray, toUrl, href } from '@execonline-inc/web-url';\ntoUrl(\"https://example.com\").map(putQueryParamArray(\"foo\", [\"bar\", \"baz\"])).map(href) // Just(\"https://example.com?foo=bar&foo=baz\")\n```\n\n### `putQueryParamRailsArray`\n\nThis function adds a query parameter with the given name and values to the URL, Rails-style.\n\n```ts\nimport { putQueryParamRailsArray, toUrl, href } from '@execonline-inc/web-url';\ntoUrl(\"https://example.com\").map(putQueryParamRailsArray(\"foo\", [\"bar\", \"baz\"])).map(href) // Just(\"https://example.com?foo[]=bar&foo[]=baz\")\n```\n\n### `getPathname`\n\nThis function returns the pathname of the URL.\n\n```ts\nimport { getPathname, toUrl, href } from '@execonline-inc/web-url';\ntoUrl(\"https://example.com/foo/bar\").map(getPathname).map(href) // Just(\"/foo/bar\")\n```\n\n### `setrPathname`\n\nThis function sets the pathname of the URL.\n\n```ts\nimport { setPathname, toUrl, href } from '@execonline-inc/web-url';\ntoUrl(\"https://example.com\").map(setPathname(\"/foo/bar\")).map(href) // Just(\"https://example.com/foo/bar\")\n```\n\n### `windowLocation`\n\nThis function returns the `URL` object for the current window as a `Task`.\n\n```ts\nimport { windowLocation } from '@execonline-inc/web-url';\n\nwindowLocation().fork(\n  (error: InvalidWebUrlError) => console.error(error),\n  (url: URL) => console.log(url.href) // $> \"https://example.com/foo/bar\"\n);\n```\n"}},{"slug":"cute","metadata":{"name":"@kofno/cute","description":"Immutable Stacks and Deques and such"},"markdown":{"content":"# Cute\n\n[![semantic-release](https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg?style=plastic)](https://github.com/semantic-release/semantic-release)\n\nImplementations of immutable Stacks and Deques for various use cases.\n\nCompatible with Maybeasy and CooperTS.\n\n## Install\n\n```\n> npm install --save @kofno/cute\n\n> yarn add @kofno/cute\n```\n"}},{"slug":"gaia","metadata":{"name":"@kofno/gaia","description":"Safely read values from your environment"},"markdown":{"content":"# Gaia\n\n[![semantic-release](https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg?style=plastic)](https://github.com/semantic-release/semantic-release)\n\nRead variables from the environment in a typesafe way.\n\nCompatible with Maybeasy, Resulty, and Taskarian\n"}},{"slug":"piper","metadata":{"name":"@kofno/piper","description":"Tools for functional composition"},"markdown":{"content":"# Piper\n\nFunctional composition in Typescript. This library is named after @kofno's cat. She is glorious.\n\n# install\n\n> npm install --save @kofno/piper\n\n> yarn add @kofno/piper\n\n## functions\n\n### `pipe`\n\npipe takes in a sequence of functions which process an input parameter and return a output which\nwill be used as the input for the next function in the sequence. _pipe_ is copied almost\nline-for-line from\n[RxJS](https://github.com/ReactiveX/rxjs/blob/f8a9d6e52f6ab151d08da0e7424f64f70763c830/src/internal/util/pipe.ts).\n\n\n```ts\n    import { pipe } from '@kofno/piper';\n\n    const add1 = n => n + 1;\n    const double = n => n * 2;\n\n    const doubleThenAdd1 = pipe(\n      double,\n      add1\n    );\n\n    doubleThenAdd1(2); // 5\n```\n\n### `pipeline`\n\npipeline wraps unary functions with a functor implementation so that functions can be composed using map.\n\n```ts\n      import { pipeline } from './index';\n\n      const upper = (s: string) => s.toUpperCase();\n      const split = (sep: string) => (s: string) => s.split(sep);\n      const reverse = (ss: string[]) => ss.reverse();\n      const join = (ss: string[]) => ss.join('');\n\n      const doit = pipeline(upper)\n        .map(split(''))\n        .map(reverse)\n        .map(join).fn;\n\n      doit('food') // 'DOOF'\n```\n\n### `pick`\n\npick creates a function that pulls a particular value from an object which is useful for accessing objects in a functor chain.\n\n```ts\n    import { pick } from '@kofno/piper';\n\n    const f = {\n      a: 2,\n      b: 'two',\n      c: true,\n    };\n\n    pick('a', f) // 2\n```\n"}},{"slug":"stack-ts","metadata":{"name":"@kofno/stack-ts","description":"Typescript based immutable stack"},"markdown":{"content":"# Stack\n\n[![semantic-release](https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg?style=plastic)](https://github.com/semantic-release/semantic-release)\n\nAn implementation of an immutable Stack data structure.\n\nCompatible with Maybeasy.\n\n## Install\n\n```\n> npm install --save @kofno/stack-ts\n\n> yarn add @kofno/stack-ts\n```\n"}},{"slug":"ajaxian","metadata":{"name":"ajaxian","description":"Ajax requests with better error handling"},"markdown":{"content":"# ajaxian\n\n[![semantic-release](https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg?style=flat-square)](https://github.com/semantic-release/semantic-release)\n\nAjaxian is a small wrapper around the XMLHttpRequest object. It borrows heavily\nfrom the Elm Http module. In many ways it's not all that different from other\nhttp libraries: build a request, send it to the server, and then handle the\nresponse. The emphasis here is on handling error responses correctly and\nconsistently, without resorting to thrown exceptions.\n\nBecause it uses XMLHttpRequest, Ajaxian can only be used from the browser (or\na browser-like environment, like Electron). Browserify, Webpack, or some similar\ntool may be required when packaging for deploy.\n\n## tasks\n\nInstead of Promises, Ajaxian uses Futures (here called Tasks, from the\nTaskarian library). Tasks are lazy and will not execute until forked. This\nmeans a Task can be returned from a pure function. Tasks are also composable.\nYou can build a complex chain of behaviors, while strictly controlling exactly\nwhen the side effects happen. In this way I prefer them over Promises, which\nare stateful and initiate side effects as soon as they are instantiated.\n\n## errors\n\nAjaxian does not throw errors for failed requests. Instead, failed requests\nare returned as one of several different types of errors. Error conditions\nare documented this way because I believe that you create a better user\nexperience when you handle error conditions gracefully. I want to provide\nthe tools for doing that.\n\nAll of the error types are documented in the HttpError module.\n\n## decoders\n\nDecoders are another idea stolen from Elm. A decoder is a function that converts\nthe response body of a request into a data structure that can be used by the\napplication.\n\nAjaxian expects the decoder to return the results wrapped in a Result object.\nIf the data passes muster, then the decoder should return the data wrapped in\nan Ok object. If the data is incorrect, then an error message wrapped will be\nwrapped in an Err object. This will result in a BadPayload error.\n\nIf you are building a json heavy application, I would recommend checking out\n[jsonous](https://github.com/kofno/festive-possum/tree/main/packages/jsonous). \nThis library is specifically built for creating composable decoders for handling\njson content.\n\n# installing\n\n> npm install --save ajaxian\n\n> yarn add ajaxian\n\n# usage\n\n    import { toHttpTask, Request, header } from 'ajaxian';\n    import { ok } from 'resulty';\n\n    // Create a request object. This is a TS example.\n    const request: Request<{}> = {\n      url: '/some_end_point',\n      method: 'post',\n      data: { foo: 'bar' },\n      timeout: 0,\n      headers: [header('X-Some-Header', 'baz')],\n      withCredentials: true,\n      decoder: () => ok({}),\n    };\n\n    toHttpTask(request).fork(\n      err => console.error(err),\n      data => console.log(\"Success!\", data)\n    );\n\nThere are some convenience builders for making requests, too:\n\n    import { post } from 'ajaxian';\n\n    const request = post('/some_end_point', { foo: bar }, () => ok({}))\n      .withHeader(header('X-Some-Header', 'baz'));\n\nIt is also possible to abort an HTTP request before it completes. Forking the\nHTTP task returns an abort function from the underlying HTTP request object:\n\n    const cancel = toHttpTask(request).fork(\n      err => console.error(err),\n      data => console.log(\"Success!\", data),\n    );\n\n    cancel() // <-- aborts request\n"}},{"slug":"ajaxios","metadata":{"name":"ajaxios","description":"Http requests with better error handling"},"markdown":{"content":"# ajaxios\n\n[![semantic-release](https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg?style=flat-square)](https://github.com/semantic-release/semantic-release)\n\nAjaxios is a fork of Ajaxian. The key differenence is that, where Ajaxian wraps\nXMLHttpRequest and only works in browsers, Ajaxios wraps the Axios library so\nthat it can work in browsers or Node. This means that the Ajaxios is suitable\nfor use in server side rendering or in a Node server or Lambda.\n\n[More about the Axios library](https://www.npmjs.com/package/axios).\n\nAjaxios is NOT a drop-in replacement for Ajaxian. They are very similar APIs,\nbut some concessions have been made to how Axios works differently then the\nXMLHttpRequest.\n\nAjaxios borrows heavily from the Elm Http module. In many ways it's not all\nthat different from other http libraries: build a request, send it to the\nserver, and then handle the response. The emphasis here is on handling error\nresponses correctly and consistently, without resorting to thrown exceptions.\n\n## tasks\n\nInstead of Promises, Ajaxios uses Futures (here called Tasks, from the\nTaskarian library). Tasks are lazy and will not execute until forked. This\nmeans a Task can be returned from a pure function. Tasks are also composeable.\nYou can build a complex chain of behaviors, while strictly controlling exactly\nwhen the side effects happen. In this way I prefer them over Promises, which\nare stateful and initiate side effects as soon as they are instantiated.\n\n## errors\n\nAjaxios does not throw errors for failed requests. Instead, failed requests\nare returned as one of several different types of errors. Error conditions\nare documented this way because I believe that you create a better user\nexperience when you handle error conditions gracefully. I want to provide\nthe tools for doing that.\n\nAll of the error types are documented in the HttpError module.\n\n## decoders\n\nDecoders are another idea stolen from Elm. A decoder is a monad that converts\nthe response body of a request into a data structure that can be used by the\napplication.\n\nAjaxios uses Jsonous (as a peer dependency) to describe decoders.\n\nIf the data passes muster, then the decoder returns the data wrapped in\nan Ok object. If the data is incorrect, then an error message will be\nwrapped in an Err object and Ajaxios will return the result as a BadPayload\nerror.\n\n# installing\n\n> npm install --save ajaxios\n\n> yarn add ajaxios\n\n# usage\n\n    import { toHttpTask, Request, header } from 'ajaxios';\n    import { succeed } from 'jsonous';\n\n    // Create a request object. This is a TS example.\n    const request: Request<{}> = {\n      url: '/some_end_point',\n      method: 'post',\n      data: { foo: 'bar' },\n      timeout: 0,\n      headers: [header('X-Some-Header', 'baz')],\n      withCredentials: true,\n      decoder: succeed({}),\n    };\n\n    toHttpTask(request).fork(\n      err => console.error(err),\n      data => console.log(\"Success!\", data)\n    );\n\nThere are some convenience builders for making requests, too:\n\n    import { post } from 'ajaxios';\n\n    const request = post('/some_end_point', { foo: bar }, succeed({}))\n      .withHeader(header('X-Some-Header', 'baz'));\n\nIt is also possible to abort an HTTP request before it completes. Forking the\nHTTP task returns an abort function from the underlying HTTP request object:\n\n    const cancel = toHttpTask(request).fork(\n      err => console.error(err),\n      data => console.log(\"Success!\", data),\n    );\n\n    cancel() // <-- aborts request\n"}},{"slug":"jsonous","metadata":{"name":"jsonous","description":"Type safe JSON decoding for JavaScript"},"markdown":{"content":"# jsonous\n\n[![semantic-release](https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg)](https://github.com/semantic-release/semantic-release)\n\nIf you're building a web application, you're eventually going to need a reliable\nway to convert JSON into type that you can use. `JSON.parse` will only get you\nso far.\n\nA better solution allows you to verify the structure of the source data while\nconverting it into the types you need to work with. It handles variations in\ncontent structure. In a typed environment, it preserves your types so you don't\nhave to pass `any` types around. Errors are handled gracefully using a Result\ntype.\n\nThis library, heavily inspired by Elm's [JSON Decoder](http://package.elm-lang.org/packages/elm-lang/core/latest/Json-Decode), is just\nsuch a solution.\n\n# install\n\n> npm install --save jsonous\n\n> yarn add jsonous\n\n# usage\n\n## primitives\n\nThere are several decoders for handling JSON primitives; strings, numbers,\nbooleans, and arrays (more on objects later)\n\n```typescript\nstring.decodeJson('\"foo\"'); // --> Ok(\"foo\")\nstring.decodeJson('42'); // --> Err(\"42 is not a string\")\n\nnumber.decodeJson('42'); // --> Ok(42)\nnumber.decodeJson('\"foo\"'); // --> Err(\"foo is not a number\")\n\nboolean.decodeJson('true'); // --> Ok(true)\nboolean.decodeJson('\"foo\"'); // --> Err(\"foo is not a boolean\")\n```\n\n## arrays\n\nThe array primitive applies another decoder to an array of values.\n\n```typescript\narray(string).decodeJson('[\"foo\", \"bar\"]'); // --> Ok([\"foo\", \"bar\"])\narray(string).decodeJson('[\"foo\", 42]'); // --> Err(\"42 is not a string\")\n```\n\n## objects\n\nThe `field` and `at` decoders are used to extract values from objects.\n\n```typescript\nfield('bar', string).decodeAny({ bar: 'baz' }); // --> Ok('baz')\nat(['foo', 0, 'bar'], number).decodeAny({ foo: [{ bar: 42 }] }); // --> Ok(42)\n```\n\nObject decoders can be chained together to build more complex data structures.\n\n```typescript\n// prettier-ignore\nfield('userId', number).andThen(id =>\nfield('emailAddress', string).andThen(email =>\nsucceed({ id, email })))\n.decodeAny({ userId: 213, emailAddress: 'foo@example.com' })\n// --> Ok({ id: 213, email: 'foo@example.com'})\n```\n\nOf course, your code editor may try to reformat this code.\n\n```typescript\nfield('userId', number)\n  .andThen((id) =>\n    field('emailAddress', string).andThen((email) => succeed({ id, email }))\n  )\n  .decodeAny({ userId: 213, emailAddress: 'foo@example.com' });\n// --> Ok({ id: 213, email: 'foo@example.com'})\n```\n\nFor an object of any moderate complexity, this nesting is indistinguishable from\ncallback hell.\n\nTo combat this, decoders have a method named `assign`. It enacapsulates this\npattern of building objects such that objects can be built incrementally, without\nnesting and without losing type safety.\n\nThe previous example would look like this using `assign`:\n\n```typescript\nsucceed({})\n  .assign('id', field('userId', number))\n  .assign('email', field('emailAddress', string))\n  .decodeAny({ userId: 213, emailAddress: 'foo@example.com' });\n// --> Ok({ id: 213, email: 'foo@example.com' })\n```\n\nThe best strategy for handling object construction with decoders\nis to compose complex decoders from smaller, simpler decoders.\n\n```typescript\nsucceed({})\n  .assign('user', field('user', userDecoder))\n  .assign('courses', at(['student', 'courses'], array(courseDecoder)))\n  .decodeJson('... some json ... ')\n\nconst userDecoder = //...\nconst courseDecoder = //...\n```\n\n# docs\n\n[API](https://kofno.github.io/jsonous)\n"}},{"slug":"maybeasy","metadata":{"name":"maybeasy","description":"Maybe implemented in TypeScript"},"markdown":{"content":"# maybeasy\n\n[![semantic-release](https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg?style=plastic)](https://github.com/semantic-release/semantic-release)\n\nWhether we like it or not, not every computation in a program is going to\nreturn a value. Sometimes there's no value to return. Other times, something\ngoes wrong and we're just not sure what value to return.\n\nIn JavaScript we often will return null or undefined to represent the value\nof Nothing, however we arrive at that value. This can often lead to failures\nat runtime when we forget (or are unaware) that a value may be nothing.\nStrict null checking makes this situation tolerable in Typescript, if only by\nnagging you every place you need to check for Nothing.\n\nArrays are less prone to these types of failures, because if when there is\nnothing, we return an empty array. We can safely apply functions to an array\nwithout being concerned if there are values present, because an empty array and\na populated array have the same interface. Can that same principle be applied\nto singular values?\n\nSure it can! The Maybe type offers a way to express that a value may be something,\nor it may be nothing. Our intuition for mapping over arrays is applicable here.\n\n## the functor (this map)\n\nGiven a computation that may or may not return a value, we can apply logic to\nthis value by mapping pure functions over the result of the computation. For\nexample:\n\n```typescript\nconst fetchSomething = (): Maybe<number> => ...; // <-- may or may not return something\n\nconst add2 = (n) => n + 2;\n\nfetchSomething().map(add2); //\n```\n\nIn this example, we add2 to the number that we fetched. But if the there is no\nnumber -- it's Nothing -- the result of add2 is... Nothing. We won't get a\nruntime error.\n\n## chaining (the flat map)\n\nLet's say that we have two computations. Both may return nothing, but one of the\ncomputations depends on the other.\n\n```typescript\nconst fetchSomething = (): Maybe<number> => ...;\n\nconst fetchSomethingElse = (n: number): Maybe<string> => ...; // <-- also may or may not return something\n```\n\nWe _could_ use a map here, as in this examples:\n\n```typescript\nfetchSomething().map(fetchSomethingElse);\n```\n\nThe problem with this is that we will end up a maybe nested inside another maybe.\nYou intuition for Arrays applies here, too; if we map over an Array with a function\nthat returns an Array, we end up with an Array of Arrays. That same thinking\napplies here; we'll end up with `Maybe<Maybe<string>>`.\n\nTo chain computations that both may return nothing, we need a different tool:\n`andThen`. We can rewrite our previous example, but just replace `map` with\n`andThen`:\n\n```typescript\nfetchSomething().andThen(fetchSomethingElse);\n```\n\nIf either computation is Nothing, the result is nothing. If both computations\nsucceed, then we have `Maybe<string>`.\n\n## building an object\n\nA common pattern in javascript is build an object from a set of computations.\nWhen those computations may or may not return a value, it can be useful to\nchain them together using Maybe.\n\nGiven our functions, you can chain them together using `andThen`. It looks like\nthis:\n\n```typescript\nfetchSomething().andThen(a => fetchSomethingElse.andThen(b => just({ a, b })));\n```\n\nIf the object is fairly complex, this nesting can be quite deep.\n\n```typescript\nfetchSomething()\n.andThen(a =>\n  fetchSomethingElse().andThen(b =>\n    fetchC().andThen(c =>\n      fetchD().andThen(d =>\n        fetchE().andThen(e =>\n          ({ a, b, c, d, e })\n        )\n       )\n      )\n    );\n```\n\nThis is barely distinguishable from callback hell. The `assign` method helps\nflatten this out by allowing us to build an object incrementally. Here's the\nlast code example using `assign`:\n\n```typescript\njust({})\n  .assign('a', fetchSomething())\n  .assign('b', fetchSomethingElse())\n  .assign('c', fetchC())\n  .assign('d', fetchD())\n  .assign('e', fetchE());\n```\n\n`assign` also accepts a function that returns a Maybe value as the second argument.\nUse this when you need to calculate one value of the object, based on a previously\ncalculated value. For example:\n\n```typescript\njust({})\n  .assign('a', just(8))\n  .assign('b', scope => just(scope.a + 42)); // --> Just { a: 8, b: 50 }\n```\n\n## unwrapping the value\n\nAt some point, we may need to send our result to another part of the system.\nThe other part of the system may not understand Maybe values. Or possibly this\nvalue needs to be serialized as a string for sending to a third party. We need\na safe way to _unwrap_ this value. For this purpose we have `getOrElse` and\n`getOrElseValue`.\n\n`getOrElse` and `getOrElseValue` will return the value if it is present (a Just),\nbut also requires us to provide a default value, in the case that we have Nothing.\n`getOrElseValue` is strict and takes a value of the generic type of the Maybe.\n`getOrElse` is lazy. It takes a function that returns a type of the generic\ntype of the Maybe. The function will only be evaluated if the Maybe is Nothing.\nPrefer usinf `getOrElse` if the default value is expensive to calculate.\n\nThis makes _unwrapping_ the value safe.\n\n## putting it all together\n\nWe can, of course, chain and map all we want to create a pipeline of data processors.\nAt the end we can unwrap our value for consumption by humans or other systems.\nFor example:\n\n```typescript\nfetchSomething()\n  .map(add2)\n  .andThen(fetchSomethingElse)\n  .getOrElse('No data');\n```\n\n# install\n\n> npm install --save maybeasy\n\n> yarn add maybeasy\n\n# usage\n\n```typescript\nimport { just, nothing } from 'maybeasy';\n\nfunction parse(s) {\n  try {\n    return just(JSON.parse(s));\n  } catch (e) {\n    return nothing();\n  }\n}\n```\n\n# docs\n\n[API](https://kofno.github.io/maybeasy)\n"}},{"slug":"nonempty-list","metadata":{"name":"nonempty-list","description":"A list that always has at least one thing in it."},"markdown":{"content":"# NonEmpty List\n\nAn immutable data structure that acts like a list but guarantees that the list always has at least \none item.\n\n## Constructor\n\nBecause a `NonEmptyList<T>` guarantees the presence of at least one `T`, the constructor requires\na `T` object.\n\n```typescript\nconst strings = new NonEmptyList('hello', ['world'])\nconst numbers = new NonEmptyList(1, [2, 3, 4])\n```\n\n## Other Construction Functions\n\n### `fromValue`\n\nCreate a `NonEmptyList<T>` from a single `T`.\n\n```typescript\nconst numbers = fromValue(1); // Equivalent to new NonEmptyList(1, [])\n```\n\n### `fromArray`\n\nCreate a `NonEmptyList<T>` from an `Array<T>`, returning a [`Result<string, NonEmptyList<T>>`]. If \nthe array is empty return an error result, otherwise return a new non-empty list in an okay result.\n\nUseful when the array is not known statically.\n\n```typescript\nconst someArrayOfNumbers: Array<number> = calculateOrFetchTheArray();\nconst numbers: Result<string, NonEmptyList<number>> = fromArray(someArrayOfNumbers)\n```\n\n[`Result<string, NonEmptyList<T>>`]: https://github.com/kofno/festive-possum/tree/main/packages/resulty\n\n### `fromArrayMaybe`\n\nSimilar to `fromArray`, but return a [`Maybe<NonEmptyList<T>>`]. Useful when the array is not known\nstatically.\n\n```typescript\nconst someArrayOfNumbers: Array<number> = calculateOrFetchTheArray();\nconst numbers: Maybe<NonEmptyList<number>> = fromArrayMaybe(someArrayOfNumbers)\n```\n\n[`Maybe<NonEmptyList<T>>`]: https://github.com/kofno/festive-possum/tree/main/packages/maybeasy\n\n## Attributes\n\n### `first`\n\nThe first element in the list, guaranteed to exist.\n\n```typescript\nconst numbers = new NonEmptyList(1, [2, 3, 4])\nnumbers.first // 1\n```\n\n### `rest`\n\nAn array of the rest of the elements in the list. May be empty.\n\n```typescript\nconst numbers = new NonEmptyList(1, [2, 3, 4])\nnumbers.rest // [2, 3, 4]\n\nconst strings = new NonEmptyList('hello world', [])\nstrings.rest // []\n```\n\n### `length`\n\nThe number of elements in the list.\n\n```typescript\nconst numbers = new NonEmptyList(1, [2, 3, 4])\nnumbers.length // 4\n```\n\n## Methods\n\n### `reverse`\n\nReturns a new `NonEmptyList` with the items reversed.\n\n```typescript\nconst numbers = new NonEmptyList(1, [2, 3, 4])\nconst reversed = numbers.reverse()\nnumbers.first // 1\nreversed.first // 4\n```\n\n### `includes`\n\nIndicate whether the list includes some value.\n\n```typescript\nconst numbers = new NonEmptyList(1, [2, 3, 4])\nnumbers.includes(2) // true\nnumbers.includes(8) // false\n```\n\n### `take`\n\nReturn an array of the first `count` elements.\n\n```typescript\nconst numbers = new NonEmptyList(1, [2, 3, 4])\nnumbers.take(2) // [1, 2]\n```\n\n### `drop`\n\nReturn an array after dropping the first `count` elements.\n\n```typescript\nconst numbers = new NonEmptyList(1, [2, 3, 4])\nnumbers.drop(2) // [3, 4]\n```\n\n### `concat`\n\nTakes either an `Array` or another `NonEmptyList`, and returns a new `NonEmptyList` with the current\nand given lists concatenated.\n\n\n```typescript\nconst firstTwo = new NonEmptyList(1, [2])\nconst numbers = firstTwo.concat([3, 4])\nnumbers.first // 1\nnumbers.rest // [2, 3, 4]\n```\n\n### `every`\n\nSimilar to [`Array.prototype.every()`]: for some predicate, does every element in the list return\n`true`?\n\n```typescript\nconst numbers = new NonEmptyList(1, [2, 3, 4])\nnumbers.every(n => n < 5) // true\nnumbers.every(n => n < 4) // false\n```\n\n[`Array.prototype.every()`]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every\n\n### `some`\n\nSimilar to [`Array.prototype.some()`]: for some predicate, does some element in the list return \n`true`?\n\n```typescript\nconst numbers = new NonEmptyList(1, [2, 3, 4])\nnumbers.some(n => n < 4) // true\nnumbers.some(n => n > 4) // false\n```\n\n[`Array.prototype.some()`]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some\n\n### `find`\n\nAttempt to find an element where the given predicate returns `true`. Return [`Maybe<T>`].\n\n```typescript\nconst numbers = new NonEmptyList(1, [2, 3, 4])\nnumbers.find(n => n < 4) // just(1)\nnumbers.find(n => n > 4) // nothing()\n```\n\n[`Maybe<T>`]: https://github.com/kofno/festive-possum/tree/main/packages/maybeasy\n\n### `map`\n\nSimilar to [`Array.prototype.map()`]: create a new `NonEmptyList` by evaluating the callback for\nevery item in the current list.\n\n```typescript\nconst numbers = new NonEmptyList(1, [2, 3, 4])\nconst mapped = numbers.map(n => n * 2).map(String)\nmapped.first // \"2\"\nmapped.rest // [\"4\", \"6\", \"8\"]\n```\n\n[`Array.prototype.map()`]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map\n\n### `and`\n\nAlias of [`map`](#map).\n\n### `andThen`\n\nSimilar to [`Array.prototype.flatMap()`]. Given a callback that returns a new `NonEmptyList<U>` when\nevaluated on an item `T`, return the result of mapping over the current list, and then flattening\nall the new lists into a single `NonEmptyList<U>`.\n\n```typescript\nconst numbers = new NonEmptyList(1, [2, 3, 4])\nconst createPair = (n: number) => new NonEmptyList(n, [n])\nconst pairs = numbers.andThen(createPair)\npairs.first // 1\npairs.rest // [1, 2, 2, 3, 3, 4, 4]\n```\n\n[`Array.prototype.flatMap()`]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap\n\n### `reduce`\n\nSimilar to [`Array.prototype.reduce()`]: \"reduce\" the array of values into a single value.\n\n```typescript\nconst numbers = new NonEmptyList(1, [2, 3, 4])\nnumbers.reduce((sum, n) => sum + n) // 10\n```\n\n[`Array.prototype.reduce()`]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce\n\n### `filter`\n\nSimilar to [`Array.prototype.filter()`]: return an `Array` of values for which some predicate\nreturns `true`.\n\n```typescript\nconst numbers = new NonEmptyList(1, [2, 3, 4])\nnumbers.filter(n => n % 2 === 0) // [2, 4]\n```\n\n[`Array.prototype.filter()`]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter\n\n### `sort`\n\nReturns a new `NonEmptyList` with the items sorted using [`Array.prototype.sort()`].\n\n```typescript\nconst scrambled = new NonEmptyList(3, [1, 4, 2])\nconst sorted = numbers.sort()\nscrambled.first // 3\nsorted.first // 1\n```\n\n[`Array.prototype.sort()`]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\n\n### `join`\n\nEquivalent to [`Array.prototype.join()`].\n\n```typescript\nconst numbers = new NonEmptyList(1, [2, 3, 4])\nnumbers.join(', ') // \"1, 2, 3, 4\"\n```\n\n[`Array.prototype.join()`]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join\n\n### `toArray`\n\nReturn an `Array` of the elements in the list.\n\n```typescript\nconst numbers = new NonEmptyList(1, [2, 3, 4])\nnumbers.toArray() // [1, 2, 3, 4]\n```\n"}},{"slug":"resulty","metadata":{"name":"resulty","description":"A return type for computations that may fail"},"markdown":{"content":"# resulty\n\n[![semantic-release](https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg?style=plastic)](https://github.com/semantic-release/semantic-release)\n\n\nA disjunction implementation in TypeScript.\n\n# install\n\n> npm install --save resulty\n\n> yarn add resulty\n\n# usage\n\n    import { ok, err } from 'resulty';\n\n    function parse(s) {\n      try {\n        return ok(JSON.parse(s));\n      }\n      catch(e) {\n        return err(e.message);\n      }\n    }\n\n# docs\n\n[API](https://kofno.github.io/resulty)\n"}},{"slug":"taskarian","metadata":{"name":"taskarian","description":"A future implementation in TypeScript"},"markdown":{"content":"# taskarian\n\n[![semantic-release](https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg?style=plastic)](https://github.com/semantic-release/semantic-release)\n\nA Task (Future) implementation in TypeScript. Useful for managing asynchronous tasks\nthat may fail.\n\nA Task is different then a Promise because it is lazy, rather then eager. A Promise\nruns as soon as you instantiate it. A Task doesn't run until you call `fork`.\nPure functions can return tasks (just not execute them). This means that you\ncould, for example, return a task from a Redux reducer, if that's your thing.\n\n# install\n\n> npm install --save taskarian\n\n> yarn add taskarian\n\n# usage\n\n    import Task from 'taskarian';\n\n    function parse(s) {\n      return new Task(function(reject, resolve) {\n        try {\n          resolve(JSON.parse(s));\n        }\n        catch(e) {\n          reject(e.message);\n        }\n      });\n    }\n\n    parse('foo').fork(\n      function(err) { console.error(err) },\n      function(value) { console.log(value) }\n    );\n\nIt is also possible to cancel a task, if the task supports it:\n\n    import Task, { Resolve } from 'taskarian';\n\n    const cancellable = new Task((reject, resolve: Resolve<string>) => {\n      const x = setTimeout(() => resolve('Yo!'), 3000);\n      return () => clearTimeout(x);\n    });\n\n    const cancel = task.fork(\n      err => console.error(err),\n      s => console.warn(`Task should never have finished; ${s}`),\n    );\n\n    cancel();\n\n# docs\n\n[API](https://kofno.github.io/taskarian)\n"}}],"navTree":[{"title":"About","href":"/about","links":[]},{"title":"Guide","href":"/guide","links":[{"title":"CooperTS - Practical Patterns","href":"/guide/practical-patterns"}]},{"title":"Examples","href":"/examples","links":[{"title":"Task Manager App","href":"/examples#task-manager-app"},{"title":"Cellular Automata Emulator","href":"/examples#cellular-automata-emulator"},{"title":"This Doc Site 😁","href":"/examples#this-doc-site"}]},{"title":"Frequently Asked Questions","href":"/faq","links":[{"title":"What's All This About Map Then?","href":"/faq/about-map"},{"title":"Avoiding The Billion Dollar Mistake","href":"/faq/billion-dollar-mistake"},{"title":"When to Use Which - getOrElse vs getOrElseValue","href":"/faq/getorelse-vs-getorelsevalue"},{"title":"Imperative vs Declarative Programming","href":"/faq/imperative-vs-declarative"},{"title":"When To Use Which - map vs. andThen","href":"/faq/map-vs-andthen"},{"title":"When To Use Which - Maybe vs Result vs Task (and other Monads)","href":"/faq/monads"}]},{"title":"Packages","href":"/packages","links":[{"title":"ajaxian","href":"/packages/ajaxian"},{"title":"ajaxios","href":"/packages/ajaxios"},{"title":"@kofno/cute","href":"/packages/cute"},{"title":"@kofno/gaia","href":"/packages/gaia"},{"title":"jsonous","href":"/packages/jsonous"},{"title":"maybeasy","href":"/packages/maybeasy"},{"title":"nonempty-list","href":"/packages/nonempty-list"},{"title":"@kofno/piper","href":"/packages/piper"},{"title":"resulty","href":"/packages/resulty"},{"title":"@kofno/stack-ts","href":"/packages/stack-ts"},{"title":"taskarian","href":"/packages/taskarian"},{"title":"@execonline-inc/appy","href":"/packages/appy"},{"title":"@execonline-inc/collections","href":"/packages/collections"},{"title":"@execonline-inc/decoders","href":"/packages/decoders"},{"title":"@execonline-inc/dom","href":"/packages/dom"},{"title":"@execonline-inc/environment","href":"/packages/environment"},{"title":"@execonline-inc/error-handling","href":"/packages/error-handling"},{"title":"@execonline-inc/logging","href":"/packages/logging"},{"title":"@execonline-inc/maybe-adapter","href":"/packages/maybe-adapter"},{"title":"@execonline-inc/numbers","href":"/packages/numbers"},{"title":"@execonline-inc/resource","href":"/packages/resource"},{"title":"@execonline-inc/strings","href":"/packages/strings"},{"title":"@execonline-inc/time","href":"/packages/time"},{"title":"@execonline-inc/time-distance","href":"/packages/time-distance"},{"title":"@execonline-inc/translations","href":"/packages/translations"},{"title":"@execonline-inc/url","href":"/packages/url"},{"title":"@execonline-inc/web-url","href":"/packages/web-url"}]}]},"__N_SSG":true}