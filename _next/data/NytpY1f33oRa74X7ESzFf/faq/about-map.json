{"pageProps":{"page":{"slug":"about-map","frontmatter":{"title":"What's All This About Map Then?","description":""},"markdown":{"content":"\n## Caveats and Disclaimers\n\nI make no guarantees that the code examples compile or execute. All code examples are syntactically similar to Typescript, but should be treated as pseudo-code. Also, I expect to reference behaviors (methods, etc) that actually don't exist in the JavaScript standard library (though it'd be nice if some of them did). I try to call out where I'm doing this, but really who knows if I got every case. The intent of this is not because I'm lazy (well, not exclusively because I'm lazy), but because I want to emphasize the concepts, and not muddy the waters of learning with the intricacies of the JavaScript implementation reality.\n\nWith that out of the way, on to the topic at hand...\n\n## But First... (a Pure Function Primer)\n\nBefore we tackle Map and AndThen, we should make sure that we are all on the same page about functions.\n\nIn the mathematical sense, a function is just a mapping from a Set of inputs to a Set of outputs. The output for any given input will always be the same. In the programming world, we call these functions \"pure\" functions. and they are becoming quite popular.\n\nPure functions are defined by having no side effects and always returning the same value for the same arguments.This idea is often called \"referential integrity\", which simply means that if you replace your function call with the value returned from the function, your program doesn't break.\n\nLet's take a moment to explore referential integrity. Given this function:\n\n### add2\n\n```typescript\nconst add2 = (n: number) => n + 2;\n```\n\nThen this program:\n\n### referential program 1\n\n```typescript\nadd2(2) === 4;\n```\n\nis identical to this program:\n\n### referential program 2\n\n```typescript\n4 === 4;\n```\n\nSo.. that was probably a tad underwhelming.\n\nNow let's consider a slightly different version of add2.\n\n### side effectual add2\n\n```typescript\nconst add2 = (n: number) => {\n  sendEngagement(`Someone added 2 to ${n}`);\n  return n + 2;\n};\n```\n\nNow when I replace add2(2) === 4 with 4 === 4, how many Product Managers am I going to have in my inbox in the morning because the add2 engagements are broken? Imagine trying to write tests for both versions of add2. Which one is easier?\n\nThe problem with the second version of add2 is that has side effects in addition to the computation we were expecting. Side effects could include mutating inputs, modifying global variables, I/O operations (reading writing to disk, http requests, reading environment variables, etc.). You can't have a meaningful program without side-effects, but a key tenant of CooperTS is that we want to separate our side effects from our business logic. This makes the business logic easier to write and understand, while isolating parts of the code that are going to fail at runtime.\n\nSo why did we go through all this just to talk about Map and AndThen? Well, the laws that govern how Map and AndThen work assume that the functions that are passed in are pure. Applying side effectual behaviors using Map and AndThen are generally discouraged as they subvert optimizations and logic that the mapping behavior is applying in the implementation. Map, after, all isn't just a stylistic preference for looping.\n\nWith all that out of the way, let's look at Map and AndThen as applied to Arrays.\n\n## The Array\n\nSo let's look at a map in the familiar context of an Array.\n\nBefore we begin, let's define some types to work with:\n\n### Types.ts\n\n```typescript\ninterface Encoding {\n  id: string;\n  name: string;\n}\n\ninterface Stream {\n  id: string;\n  codec: string;\n}\n\ninterface Video {\n  encoding: Encoding;\n  streams: Stream[]\n}\n\nconst videos: Video[] = // ... assume we initialized this array with videos\n```\n\nNow lets write a couple loops. One that gets all of the encoding ids from the list of videos, and another that gets all the stream ids from the list of videos:\n\n### Get you some encoding ids\n\n```typescript\nconst encodingIds: string[] = [];\n\nfor (let i = 0; i < videos.length; i++) {\n  const id = videos[i].encoding.id;\n  encodingIds.push(id);\n}\n\nconst streamIds: string[] = [];\n\nfor (let i = 0; i < videos.length; i++) {\n  const streams = videos[i].streams;\n\n  for (let j = 0; j < streams.length; j++) {\n    const id = streams[j].id;\n    streamIds.push(id);\n  }\n}\n```\n\nIf you read this code honestly, you have to admit that it's mostly loop management and state initialization; low level concepts that muddy up our business concerns.\n\nNow let's extract the \"business logic\" into some functions:\n\n### Functions.ts\n\n```typescript\nconst getId = <T extends { id: string }>(thing: T): string => thing.id;\n\nconst getStreams = (video: Video): Stream[] => video.streams;\n\nconst getEncoding = (video: Video): Encoding => video.encoding;\n```\n\nAnd we'll try again:\n\n### Loops redeux\n\n```typescript\nconst encodingIds: string[] = [];\n\nfor (let i = 0; i < videos.length; i++) {\n  const id = getId(getEncoding(videos[i]));\n  encodingIds.push(id);\n}\n\nconst streamIds: string[] = [];\n\nfor (let i = 0; i < videos.length; i++) {\n  const streams = getStreams(videos[i]);\n\n  for (let j = 0; j < streams.length; j++) {\n    const id = getId(streams[j]);\n    streamIds.push(id);\n  }\n}\n```\n\nIs this better? Well, each piece of business logic is much easier to test now. But we're still doing loop maintenance and state management, and depending on how you feel about reading functions vs. dot notation, this might be harder for you to read.\n\nLet's look again at the encoding ids example, this time using map:\n\n### Encoding IDs, Mapped edition\n\n```typescript\nconst encodingIds: string[] = videos.map(getEncoding).map(getId);\n```\n\nAnd that's all she wrote. Loop maintenance is gone. State management is gone. All that's left are the declarations of what the logic is doing.\n\n\"So tell me...\", you may be thinking. \"How does map work?\"\n\nLet us now take a look at a hypothetical implementation of map in a hypothetical Array class:\n\n### Map's Guts\n\n```typescript\nclass Array<A> {\n  //... a bunch of stuff that makes arrays arrays\n  map = <B>(fn: (a: A) => B): Array<B> => {\n    const newArray: B[] = [];\n\n    for (let i = 0; i < this.length; i++) {\n      const b = fn(this[i]);\n      newArray.push(b);\n    }\n\n    return newArray;\n  };\n}\n```\n\nSo that's where all the loop maintenance and state management went!? Indeed. This is the power of map: It abstracts away low level considerations, and surfaces only the business concerns.\n\nNow I want to take a look at the signature of the fn argument in map and compare it to our business logic functions:\n\n### Map Signature\n\n```typescript\nfn: (a: A) => B\n\ngetId: (thing: T): string\n\ngetStreams: (video: Video): Stream[]\n\ngetEncoding: (video: Video): Encoding\n```\n\nEvery single one of our business logic functions is compatible with map. And this will be true of any pure function. As long as it takes a single argument (or can be curried down to take a single argument) then that function can be used with map. And we can see in the array example that map frees up a lot of mental bandwidth, freeing up cycles that were once devoted to tracking loop and state details but can now be applied to solving actual application space problems.\n\nThis idea of map abstracting away low level details is powerful. In the array, it hides looping and state mutation. But imagine if all of your ugly, side effectual, state management details could be modeled as mappable data structures. In that world, all of your business logic could be written in easily tested, easily reasoned about, type checkable, pure functions. No mocks. No browser. No environment considerations. WOW!\n\nOf course, when everything seems rosy, there's always something that comes along and throws a wrench in the works. Let's see what happens when we apply map the stream ids case:\n\n### map stream ids\n\n```typescript\nconst streamIds: string[] = videos.map(getStreams).map((streams) => streams.map(getId));\n```\n\nUgh... getStreams is breaking my beautiful code. Since it returns an array, I have to nest a map inside another map; abstraction details are leaking out. Also, this won't compile because I've declared that I need a string[], but I'm actually getting a string[][]. Ay caramba!\n\nWe could fix the compiler error with something intensely JavaScripty, like this:\n\n### Intense JavaScript\n\n```typescript\nconst tempStreamIds: string[][] = videos.map(getStreams).map((streams) => streams.map(getId));\n\nconst streamIds: string[] = [].concat.apply([], tempStreamIds);\n```\n\nIt should compile now, but so help me... I need to know how JavaScript functions can be applied; the lowest of low level details. Calgon, take me away.\n\nWhat would be great here, is if we had a function like map, but instead of appending the results of the map function (fn), it concatenated them. What would we call such a function? How about concatMap? Let's look at a hypothetical implementation of concatMap:\n\n### concatMap\n\n```typescript\nclass Array<A> {\n  //... a bunch of stuff that makes arrays arrays\n  concatMap = <B>(fn: (a: A) => B[]): Array<B> => {\n    let newArray: B[] = [];\n\n    for (let i = 0; i < this.length; i++) {\n      const bs = fn(this[i]);\n      newArray = newArray.concat(bs);\n    }\n\n    return newArray;\n  };\n}\n```\n\nHeavens to Betsy, that looks a lot like map, doesn't it? The differences are that the fn function argument must return an array, and those arrays are being concatenated, rather then appended.\n\nWell, now that we have concatMap, let's go back and fix our streamIds:\n\n### fixed stream ids\n\n```typescript\nconst streamIds: string[] = videos.concatMap(getStreams).map(getId);\n```\n\nPhew... that is so much nicer.\n\nIn this section we've seen that map and it's close sibling concatMap are incredibly handy abstractions to have around. They de-emphasize low level details allowing us to re-emphasize business logic. In many cases, that leads to purely functional application logic that is easily tested and easily reasoned about.\n\nThat's a lot to take in. Why don't we take a break here and enjoy a Blueberry Acai Diet Coke before moving on to the next section?\n\n## Walk-thru of Map\n\nTo make sure we clearly understand what is going on here, let's walk through the map implementation for arrays. Here is the code again...\n\n### Map's Guts\n\n```typescript\nclass Array<A> {\n  //... a bunch of stuff that makes arrays arrays\n  map = <B>(fn: (a: A) => B): Array<B> => {\n    const newArray: B[] = [];\n\n    for (let i = 0; i < this.length; i++) {\n      const b = fn(this[i]);\n      newArray.push(b);\n    }\n\n    return newArray;\n  };\n}\n```\n\nLine 4: When we enter into map, the first thing that happens is a new Array is instantiated.\n\nLine 7: Then, we apply fn to each item in the array.\n\nLine 8: The result of that function call is appended to the new array.\n\nLine 11. Then we return the new array.\n\nIn the case where the array is empty, the looping logic falls through and we simply return the new, empty array.\n\n## Walk-thru of concatMap\n\nNow we'll do the same walk through, but with concatMap. Here's the code again:\n\n### concatMap\n\n```typescript\nclass Array<A> {\n  //... a bunch of stuff that makes arrays arrays\n  concatMap = <B>(fn: (a: A) => B[]): Array<B> => {\n    let newArray: B[] = [];\n\n    for (let i = 0; i < this.length; i++) {\n      const bs = fn(this[i]);\n      newArray = newArray.concat(bs);\n    }\n\n    return newArray;\n  };\n}\n```\n\nLine 4: When we enter into concatMap, we start by create a new array (same as with map)\n\nLine 7: Then we apply fn to each item in the array. In the case of concatMap, the result from fn will be another array.\n\nLine 8: Next we concatenate the array from line 7, onto the new array that we are constructing.\n\nLine 11: Finally, we return our new array, which is flattened out without any nesting.\n\nIn the case where the array is empty, the loop logic falls through and the empty array is returned.\n\n## Other Mappable Types\n\nWe can now take this understanding of map and concatMap and apply it to other mappable types. For example, let's create a data type that represents an optional value. This is a type that can replace the use of undefined. It encapsulates checks for undefined in one place, and makes it possible to cleanly chain together computations on values that may or may not be available.\n\nLet's start with a simple class definition for Optional:\n\n```typescript\nclass Optional<A> {\n  public static some = <A>(value: A) => {\n    return new Optional<A>(value);\n  };\n\n  public static none = <A>() => {\n    return new Optional<A>();\n  };\n\n  private value?: A;\n\n  private constructor(value?: A) {\n    this.value = value;\n  }\n\n  // ... more to come\n}\n```\n\nThis class has a private value that could be undefined, or it could be some generic type of A.\n\nSo far we can construct some value or we can construct a none value, but since the value is private, we can't do anything with it. Let's add a map method first, so we can at least get at the value. As we read this code, try to keep the Array map intuition in mind. The None case is like having an empty array, and the Some case is like having a one item array. Let's write this:\n\n```typescript\nclass Optional<A> {\n  // ... constructors and stuff\n\n  map = <B>(fn: (a: A) => B) => {\n    return typeof this.value !== 'undefined' ? Optional.some(fn(this.value)) : Optional.none();\n  };\n}\n```\n\nBecause there is no looping construct here, this logic is a bit more direct. We check if the value is defined. If it is, we apply fn to the value and return it wrapped in a new some. Otherwise, we return none.\n\nThe concatMap implementation is equally direct.\n\n```typescript\nclass Optional<A> {\n  // ... constructors and stuff\n\n  concatMap = <B>(fn: (a: A) => Optional<B>) => {\n    return typeof this.value !== 'undefined' ? fn(this.value) : Optional.none();\n  };\n}\n```\n\nNow we can compose operations that may fail or return no results in the same way we could chain those calls to an array. For example:\n\n```typescript\nconst add =\n  (n1: number) =>\n  (n2: number): n => {\n    return n1 + n2;\n  };\n\nconst safeDiv =\n  (dividend: number) =>\n  (divisor: number): Optional<number> => {\n    return divisor === 0 ? Optional.none() : Optional.some(dividend / divisor);\n  };\n\nOptional.some(2).map(add(-2)).concatMap(safeDiv(4));\n```\n\nRather then producing NaN, this code will return None if the division fails (divide by zero error). That makes it easier to chain operations together.\n\n## Some Final Notes\n\nWe've demonstrated the logic behind map and concatMap in terms of Arrays, so that we can leverage that intuition and apply it to other mappable types. We've even looked at some hypothetical implementations of map and concatMap to help our understanding.\n\nWhen developing using CooperTS, our default optional value is actually called Maybe. But the logic and implementation details are applicable, only the names have been changed.\n\nAlso note, concatMap can be known by many names: bind, chain, flatMap,, >>=, etc. In CooperTS libraries like Maybeasy, Taskarain, and Jsonous, concatMap is named andThen.\n\nAnd now you know the rest of the story.\n"}},"navTree":[{"title":"About","href":"/about","links":[]},{"title":"Guide","href":"/guide","links":[{"title":"CooperTS - Practical Patterns","href":"/guide/practical-patterns"}]},{"title":"Examples","href":"/examples","links":[{"title":"Task Manager App","href":"/examples#task-manager-app"},{"title":"Cellular Automata Emulator","href":"/examples#cellular-automata-emulator"},{"title":"This Doc Site 😁","href":"/examples#this-doc-site"}]},{"title":"Frequently Asked Questions","href":"/faq","links":[{"title":"What's All This About Map Then?","href":"/faq/about-map"},{"title":"Avoiding The Billion Dollar Mistake","href":"/faq/billion-dollar-mistake"},{"title":"When to Use Which - getOrElse vs getOrElseValue","href":"/faq/getorelse-vs-getorelsevalue"},{"title":"Imperative vs Declarative Programming","href":"/faq/imperative-vs-declarative"},{"title":"When To Use Which - map vs. andThen","href":"/faq/map-vs-andthen"},{"title":"When To Use Which - Maybe vs Result vs Task (and other Monads)","href":"/faq/monads"}]},{"title":"Packages","href":"/packages","links":[{"title":"ajaxian","href":"/packages/ajaxian"},{"title":"ajaxios","href":"/packages/ajaxios"},{"title":"@kofno/cute","href":"/packages/cute"},{"title":"@kofno/gaia","href":"/packages/gaia"},{"title":"jsonous","href":"/packages/jsonous"},{"title":"maybeasy","href":"/packages/maybeasy"},{"title":"nonempty-list","href":"/packages/nonempty-list"},{"title":"@kofno/piper","href":"/packages/piper"},{"title":"resulty","href":"/packages/resulty"},{"title":"@kofno/stack-ts","href":"/packages/stack-ts"},{"title":"taskarian","href":"/packages/taskarian"},{"title":"@execonline-inc/appy","href":"/packages/appy"},{"title":"@execonline-inc/collections","href":"/packages/collections"},{"title":"@execonline-inc/decoders","href":"/packages/decoders"},{"title":"@execonline-inc/dom","href":"/packages/dom"},{"title":"@execonline-inc/environment","href":"/packages/environment"},{"title":"@execonline-inc/error-handling","href":"/packages/error-handling"},{"title":"@execonline-inc/logging","href":"/packages/logging"},{"title":"@execonline-inc/maybe-adapter","href":"/packages/maybe-adapter"},{"title":"@execonline-inc/numbers","href":"/packages/numbers"},{"title":"@execonline-inc/resource","href":"/packages/resource"},{"title":"@execonline-inc/strings","href":"/packages/strings"},{"title":"@execonline-inc/time","href":"/packages/time"},{"title":"@execonline-inc/time-distance","href":"/packages/time-distance"},{"title":"@execonline-inc/translations","href":"/packages/translations"},{"title":"@execonline-inc/url","href":"/packages/url"},{"title":"@execonline-inc/web-url","href":"/packages/web-url"}]}]},"__N_SSG":true}