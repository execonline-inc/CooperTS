{"pageProps":{"packageData":{"slug":"maybeasy","metadata":{"name":"maybeasy","description":"Maybe implemented in TypeScript"},"markdown":{"content":"# maybeasy\n\n[![Build Status](https://travis-ci.org/kofno/maybeasy.svg?branch=master)](https://travis-ci.org/kofno/maybeasy)\n[![semantic-release](https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg?style=plastic)](https://github.com/semantic-release/semantic-release)\n\nWhether we like it or not, not every computation in a program is going to\nreturn a value. Sometimes there's no value to return. Other times, something\ngoes wrong and we're just not sure what value to return.\n\nIn JavaScript we often will return null or undefined to represent the value\nof Nothing, however we arrive at that value. This can often lead to failures\nat runtime when we forget (or are unaware) that a value may be nothing.\nStrict null checking makes this situation tolerable in Typescript, if only by\nnagging you every place you need to check for Nothing.\n\nArrays are less prone to these types of failures, because if when there is\nnothing, we return an empty array. We can safely apply functions to an array\nwithout being concerned if there are values present, because an empty array and\na populated array have the same interface. Can that same principle be applied\nto singular values?\n\nSure it can! The Maybe type offers a way to express that a value may be something,\nor it may be nothing. Our intuition for mapping over arrays is applicable here.\n\n## the functor (this map)\n\nGiven a computation that may or may not return a value, we can apply logic to\nthis value by mapping pure functions over the result of the computation. For\nexample:\n\n```typescript\nconst fetchSomething = (): Maybe<number> => ...; // <-- may or may not return something\n\nconst add2 = (n) => n + 2;\n\nfetchSomething().map(add2); //\n```\n\nIn this example, we add2 to the number that we fetched. But if the there is no\nnumber -- it's Nothing -- the result of add2 is... Nothing. We won't get a\nruntime error.\n\n## chaining (the flat map)\n\nLet's say that we have two computations. Both may return nothing, but one of the\ncomputations depends on the other.\n\n```typescript\nconst fetchSomething = (): Maybe<number> => ...;\n\nconst fetchSomethingElse = (n: number): Maybe<string> => ...; // <-- also may or may not return something\n```\n\nWe _could_ use a map here, as in this examples:\n\n```typescript\nfetchSomething().map(fetchSomethingElse);\n```\n\nThe problem with this is that we will end up a maybe nested inside another maybe.\nYou intuition for Arrays applies here, too; if we map over an Array with a function\nthat returns an Array, we end up with an Array of Arrays. That same thinking\napplies here; we'll end up with `Maybe<Maybe<string>>`.\n\nTo chain computations that both may return nothing, we need a different tool:\n`andThen`. We can rewrite our previous example, but just replace `map` with\n`andThen`:\n\n```typescript\nfetchSomething().andThen(fetchSomethingElse);\n```\n\nIf either computation is Nothing, the result is nothing. If both computations\nsucceed, then we have `Maybe<string>`.\n\n## building an object\n\nA common pattern in javascript is build an object from a set of computations.\nWhen those computations may or may not return a value, it can be useful to\nchain them together using Maybe.\n\nGiven our functions, you can chain them together using `andThen`. It looks like\nthis:\n\n```typescript\nfetchSomething().andThen(a => fetchSomethingElse.andThen(b => just({ a, b })));\n```\n\nIf the object is fairly complex, this nesting can be quite deep.\n\n```typescript\nfetchSomething()\n.andThen(a =>\n  fetchSomethingElse().andThen(b =>\n    fetchC().andThen(c =>\n      fetchD().andThen(d =>\n        fetchE().andThen(e =>\n          ({ a, b, c, d, e })\n        )\n       )\n      )\n    );\n```\n\nThis is barely distinguishable from callback hell. The `assign` method helps\nflatten this out by allowing us to build an object incrementally. Here's the\nlast code example using `assign`:\n\n```typescript\njust({})\n  .assign('a', fetchSomething())\n  .assign('b', fetchSomethingElse())\n  .assign('c', fetchC())\n  .assign('d', fetchD())\n  .assign('e', fetchE());\n```\n\n`assign` also accepts a function that returns a Maybe value as the second argument.\nUse this when you need to calculate one value of the object, based on a previously\ncalculated value. For example:\n\n```typescript\njust({})\n  .assign('a', just(8))\n  .assign('b', scope => just(scope.a + 42)); // --> Just { a: 8, b: 50 }\n```\n\n## unwrapping the value\n\nAt some point, we may need to send our result to another part of the system.\nThe other part of the system may not understand Maybe values. Or possibly this\nvalue needs to be serialized as a string for sending to a third party. We need\na safe way to _unwrap_ this value. For this purpose we have `getOrElse` and\n`getOrElseValue`.\n\n`getOrElse` and `getOrElseValue` will return the value if it is present (a Just),\nbut also requires us to provide a default value, in the case that we have Nothing.\n`getOrElseValue` is strict and takes a value of the generic type of the Maybe.\n`getOrElse` is lazy. It takes a function that returns a type of the generic\ntype of the Maybe. The function will only be evaluated if the Maybe is Nothing.\nPrefer usinf `getOrElse` if the default value is expensive to calculate.\n\nThis makes _unwrapping_ the value safe.\n\n## putting it all together\n\nWe can, of course, chain and map all we want to create a pipeline of data processors.\nAt the end we can unwrap our value for consumption by humans or other systems.\nFor example:\n\n```typescript\nfetchSomething()\n  .map(add2)\n  .andThen(fetchSomethingElse)\n  .getOrElse('No data');\n```\n\n# install\n\n> npm install --save maybeasy\n\n> yarn add maybeasy\n\n# usage\n\n```typescript\nimport { just, nothing } from 'maybeasy';\n\nfunction parse(s) {\n  try {\n    return just(JSON.parse(s));\n  } catch (e) {\n    return nothing();\n  }\n}\n```\n\n# docs\n\n[API](https://kofno.github.io/maybeasy)\n"}},"navTree":[{"title":"Guide","links":[{"title":"Maybe Adapter","href":"/guide/maybe"},{"title":"CooperTS - Practical Patterns","href":"/guide/practical-patterns"},{"title":"Translations Package","href":"/guide/translations"}]},{"title":"Packages","links":[{"title":"ajaxian","href":"/packages/ajaxian"},{"title":"ajaxios","href":"/packages/ajaxios"},{"title":"@kofno/cute","href":"/packages/cute"},{"title":"@kofno/gaia","href":"/packages/gaia"},{"title":"jsonous","href":"/packages/jsonous"},{"title":"maybeasy","href":"/packages/maybeasy"},{"title":"nonempty-list","href":"/packages/nonempty-list"},{"title":"@kofno/piper","href":"/packages/piper"},{"title":"resulty","href":"/packages/resulty"},{"title":"@kofno/stack-ts","href":"/packages/stack-ts"},{"title":"taskarian","href":"/packages/taskarian"},{"title":"@execonline-inc/appy","href":"/packages/appy"},{"title":"@execonline-inc/collections","href":"/packages/collections"},{"title":"@execonline-inc/decoders","href":"/packages/decoders"},{"title":"@execonline-inc/dom","href":"/packages/dom"},{"title":"@execonline-inc/environment","href":"/packages/environment"},{"title":"@execonline-inc/error-handling","href":"/packages/error-handling"},{"title":"@execonline-inc/logging","href":"/packages/logging"},{"title":"@execonline-inc/maybe-adapter","href":"/packages/maybe-adapter"},{"title":"@execonline-inc/numbers","href":"/packages/numbers"},{"title":"@execonline-inc/resource","href":"/packages/resource"},{"title":"@execonline-inc/strings","href":"/packages/strings"},{"title":"@execonline-inc/time","href":"/packages/time"},{"title":"@execonline-inc/time-distance","href":"/packages/time-distance"},{"title":"@execonline-inc/translations","href":"/packages/translations"},{"title":"@execonline-inc/url","href":"/packages/url"}]}]},"__N_SSG":true}