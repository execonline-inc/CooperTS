{"pageProps":{"pages":[{"slug":"practical-patterns","frontmatter":{"title":"CooperTS - Practical Patterns","description":"Patterns we use at ExecOnline"},"markdown":{"content":"\n# Elm-inspired functional-programming tools in Typescript.\n\n## Introduction\nThe packages in CooperTS provide many small tools for building safely with Typescript. Additionally,\nwe follow a consistent component-wide pattern to build safe reactive components as State Machines.\nWhen building a component as a state machine we create four supporting modules: [Types](#types), [Decoders](#decoders), [Stores](#stores), and [Reactions](#reactions).\n\nCompilers are great. Let the compiler do the work.\n\n## Details\n\n### Types\nTypes are how we model the state machine. A typical component that fetches data from an\nAPI endpoint might have states:\n\n- `Waiting` - The component is waiting for some triggering event before fetching the data\n- `Loading` - The component is fetching and decoding the data (see [Decoders](#decoders) below)\n- `Ready` - The component successfully fetched the data & decoded the data. This state should\n  hold the data from the API; consequently, the type for that data is also generally defined in the\n  same `Types` module.\n- `Error` - An error happened while fetching or decoding the data\n\nThe states are implemented as a [discriminated union]. They are abstractions that define how we\nthink about the state machine.\n\n[discriminated union]: https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html#discriminated-unions\n\n For example, the above states are a good way to model a page load. These types provide interfaces that we have for each of the states and the data we are receiving from the backend.\n\nThe Types.ts file is one of the simpler files to work on. Generally, it is good to start with it.  If the Types.ts file is very big, then it may make sense to break it into two or more files within a \"Types\" folder.\n\n### Decoders\n\nDecoders form our anti-corruption layer. There are two facets to this responsibility: 1) validating unknown data from external sources (the backend, a web socket, a user, a cookie, etc.); and 2) transforming that data so it fits our application model (the Types).\n\nWithin the Types file we define the structure that we will need from the backend. In the Decoder, we verify that the JSON matches the types that we defined. These decoders are built in little pieces. For example, a decoder file might only export a single decoder (e.g. StudentsResource) which is made up of many smaller decoders defined within the file.\n\n[Our resources follow a established pattern]. The resource decoder consists of a payload decoder and a Links decoder. CooperTS provides one decoder for all links and a generic resource decoder. Once we create the payload decoder, we are able to combine it with the generic resource decoder to create a specific resource decoder (e.g. StudentStore > Decoder.ts).\n\n[Our resources follow a established pattern]: https://cooperts.io/packages/resource\n\n### Stores\n\nStores are Javascript classes. We use them to model our state machines. The state is marked as a Mobx Observable and the transitions as actions. The stores describe the states that our state machines can be in and the transitions that are possible between states. For example, our model for page load has the following states: Waiting, Loading, Ready, and Error. Typical transitions are named after our states. We have a 'loading' transition that only does anything if we start from Waiting. If we trigger the  'loading' transition from a Ready state, nothing happens.\n\n### Reactions\n\nWe model asynchronous side-effects that are fired in response to observable state transitions through Reactions. This is how we enforce a separation of concerns between the store, which is purely business logic, and the side-effects, which typically involve lower level abstractions (e.g. http requests). This occurs when a store changes state. It has 1-2 functions. Its main function is 'effect.' It uses a switch statement on the current state to decide what action to perform. If the current state is Loading, it hits the API and decodes the response.\n\n### Mobx\n\nBoth Reactions and Stores are [built on Mobx]. Mobx is our state manager library that makes it effortless to respond to state changes. It's an alternative to using React Native's state. \"Anything that can be derived from the application state, should be. Automatically.\"\n\n[built on Mobx]: https://mobx.js.org/README.html\n"}}],"navTree":[{"title":"About","href":"/about","links":[]},{"title":"Guide","href":"/guide","links":[{"title":"CooperTS - Practical Patterns","href":"/guide/practical-patterns"}]},{"title":"Examples","href":"/examples","links":[{"title":"Task Manager App","href":"/examples#task-manager-app"},{"title":"Cellular Automata Emulator","href":"/examples#cellular-automata-emulator"},{"title":"This Doc Site üòÅ","href":"/examples#this-doc-site"}]},{"title":"Frequently Asked Questions","href":"/faq","links":[{"title":"What's All This About Map Then?","href":"/faq/about-map"},{"title":"Avoiding The Billion Dollar Mistake","href":"/faq/billion-dollar-mistake"},{"title":"When to Use Which - getOrElse vs getOrElseValue","href":"/faq/getorelse-vs-getorelsevalue"},{"title":"Imperative vs Declarative Programming","href":"/faq/imperative-vs-declarative"},{"title":"When To Use Which - map vs. andThen","href":"/faq/map-vs-andthen"},{"title":"When To Use Which - Maybe vs Result vs Task (and other Monads)","href":"/faq/monads"}]},{"title":"Packages","href":"/packages","links":[{"title":"ajaxian","href":"/packages/ajaxian"},{"title":"ajaxios","href":"/packages/ajaxios"},{"title":"@kofno/cute","href":"/packages/cute"},{"title":"@kofno/gaia","href":"/packages/gaia"},{"title":"jsonous","href":"/packages/jsonous"},{"title":"maybeasy","href":"/packages/maybeasy"},{"title":"nonempty-list","href":"/packages/nonempty-list"},{"title":"@kofno/piper","href":"/packages/piper"},{"title":"resulty","href":"/packages/resulty"},{"title":"@kofno/stack-ts","href":"/packages/stack-ts"},{"title":"taskarian","href":"/packages/taskarian"},{"title":"@execonline-inc/appy","href":"/packages/appy"},{"title":"@execonline-inc/collections","href":"/packages/collections"},{"title":"@execonline-inc/decoders","href":"/packages/decoders"},{"title":"@execonline-inc/dom","href":"/packages/dom"},{"title":"@execonline-inc/environment","href":"/packages/environment"},{"title":"@execonline-inc/error-handling","href":"/packages/error-handling"},{"title":"@execonline-inc/logging","href":"/packages/logging"},{"title":"@execonline-inc/maybe-adapter","href":"/packages/maybe-adapter"},{"title":"@execonline-inc/numbers","href":"/packages/numbers"},{"title":"@execonline-inc/resource","href":"/packages/resource"},{"title":"@execonline-inc/strings","href":"/packages/strings"},{"title":"@execonline-inc/time","href":"/packages/time"},{"title":"@execonline-inc/time-distance","href":"/packages/time-distance"},{"title":"@execonline-inc/translations","href":"/packages/translations"},{"title":"@execonline-inc/url","href":"/packages/url"}]}]},"__N_SSG":true}