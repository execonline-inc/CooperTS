{"pageProps":{"page":{"slug":"monads","frontmatter":{"title":"When To Use Which - Maybe vs Result vs Task (and other Monads)","description":""},"markdown":{"content":"\nThere is often confusion about when to use each of these types since they have such similar interfaces.\n\nThe first thing to understand about these types is that their similarity is because they are all Monads. All monads will have the same interface, though they may have different uses. In some cases, the difference will be obvious. In some cases, it may be just the difference of intent. We‚Äôll explore these differences by first looking at monads that have obviously different purposes.\n\n## Monads\n\nA Monad is a data abstraction that allows programs to be structured generically. A particular Monad represents a specific form of computation. The consistent interface allows programs to look the same, regardless of the nature of the computation being performed.\n\nWe‚Äôll discuss the most commonly used monads in our system here, but there is no real limit to the types of computations that monads can represent. But the goal of the abstraction is to separate the lower-level abstraction from the higher-level abstraction, level the purpose of the code clear.\n\n### Lists (Nonempty Lists)\n\nA List monad is used when we are expecting the result of a computation to be indeterminate. If I ask for people named ‚ÄúSmith‚Äù, I may be zero people or I may get 100 people. The key is that I don‚Äôt know ahead of time how large the result set of the computation is.\n\nIn the case of a non-empty list, the computation is expected to produce at least one result.\n\n### Decoders\n\nA decoder is used when a computation must rely on an unknown data type. With decoders, we can validate unknown data and transform it into something useful in the application context.\n\n### Maybe\n\nMaybe is used for computations that may fail, but the failure either isn‚Äôt an error condition, or the reason for the failure isn‚Äôt important. For example, using our find function on an array returns a Maybe type, because the value may not be in the array.\n\nMaybe is strongly preferred over using null, undefined, empty string, -1, or any other imperative style representations of computational failure.\n\n### Result\n\nResult is used for computations that may fail, but the reason for the failure is important. Decoders use Result types internally to handle the error reporting.\n\n### Task\n\nA Task is used for computations that may fail and the reason for failure is important. They differ from Results though because it is a lazy abstraction. The computation isn‚Äôt run until the Task is forked. This makes Tasks ideal for asynchronous operations.\n\nTasks are more determinate and have fewer foot guns than Promises.\n"}},"navTree":[{"title":"About","href":"/about","links":[]},{"title":"Guide","href":"/guide","links":[{"title":"Maybe Adapter","href":"/guide/maybe"},{"title":"CooperTS - Practical Patterns","href":"/guide/practical-patterns"},{"title":"Translations Package","href":"/guide/translations"}]},{"title":"Examples","href":"/examples","links":[{"title":"Task Manager App","href":"/examples#task-manager-app"},{"title":"Cellular Automata Emulator","href":"/examples#cellular-automata-emulator"},{"title":"This Doc Site üòÅ","href":"/examples#this-doc-site"}]},{"title":"Frequently Asked Questions","href":"/faq","links":[{"title":"What's All This About Map Then?","href":"/faq/about-map"},{"title":"Avoiding The Billion Dollar Mistake","href":"/faq/billion-dollar-mistake"},{"title":"When to Use Which - getOrElse vs getOrElseValue","href":"/faq/getorelse-vs-getorelsevalue"},{"title":"Imperative vs Declarative Programming","href":"/faq/imperative-vs-declarative"},{"title":"When To Use Which - map vs. andThen","href":"/faq/map-vs-andthen"},{"title":"When To Use Which - Maybe vs Result vs Task (and other Monads)","href":"/faq/monads"}]},{"title":"Packages","href":"/packages","links":[{"title":"ajaxian","href":"/packages/ajaxian"},{"title":"ajaxios","href":"/packages/ajaxios"},{"title":"@kofno/cute","href":"/packages/cute"},{"title":"@kofno/gaia","href":"/packages/gaia"},{"title":"jsonous","href":"/packages/jsonous"},{"title":"maybeasy","href":"/packages/maybeasy"},{"title":"nonempty-list","href":"/packages/nonempty-list"},{"title":"@kofno/piper","href":"/packages/piper"},{"title":"resulty","href":"/packages/resulty"},{"title":"@kofno/stack-ts","href":"/packages/stack-ts"},{"title":"taskarian","href":"/packages/taskarian"},{"title":"@execonline-inc/appy","href":"/packages/appy"},{"title":"@execonline-inc/collections","href":"/packages/collections"},{"title":"@execonline-inc/decoders","href":"/packages/decoders"},{"title":"@execonline-inc/dom","href":"/packages/dom"},{"title":"@execonline-inc/environment","href":"/packages/environment"},{"title":"@execonline-inc/error-handling","href":"/packages/error-handling"},{"title":"@execonline-inc/logging","href":"/packages/logging"},{"title":"@execonline-inc/maybe-adapter","href":"/packages/maybe-adapter"},{"title":"@execonline-inc/numbers","href":"/packages/numbers"},{"title":"@execonline-inc/resource","href":"/packages/resource"},{"title":"@execonline-inc/strings","href":"/packages/strings"},{"title":"@execonline-inc/time","href":"/packages/time"},{"title":"@execonline-inc/time-distance","href":"/packages/time-distance"},{"title":"@execonline-inc/translations","href":"/packages/translations"},{"title":"@execonline-inc/url","href":"/packages/url"}]}]},"__N_SSG":true}