{"pageProps":{"packageData":{"slug":"jsonous","metadata":{"name":"jsonous","description":"Type safe JSON decoding for JavaScript"},"readme":"# jsonous\n\n[![semantic-release](https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg)](https://github.com/semantic-release/semantic-release)\n\nIf you're building a web application, you're eventually going to need a reliable\nway to convert JSON into type that you can use. `JSON.parse` will only get you\nso far.\n\nA better solution allows you to verify the structure of the source data while\nconverting it into the types you need to work with. It handles variations in\ncontent structure. In a typed environment, it preserves your types so you don't\nhave to pass `any` types around. Errors are handled gracefully using a Result\ntype.\n\nThis library, heavily inspired by Elm's [JSON Decoder](http://package.elm-lang.org/packages/elm-lang/core/latest/Json-Decode), is just\nsuch a solution.\n\n# install\n\n> npm install --save jsonous\n\n> yarn add jsonous\n\n# usage\n\n## primitives\n\nThere are several decoders for handling JSON primitives; strings, numbers,\nbooleans, and arrays (more on objects later)\n\n```typescript\nstring.decodeJson('\"foo\"'); // --> Ok(\"foo\")\nstring.decodeJson('42'); // --> Err(\"42 is not a string\")\n\nnumber.decodeJson('42'); // --> Ok(42)\nnumber.decodeJson('\"foo\"'); // --> Err(\"foo is not a number\")\n\nboolean.decodeJson('true'); // --> Ok(true)\nboolean.decodeJson('\"foo\"'); // --> Err(\"foo is not a boolean\")\n```\n\n## arrays\n\nThe array primitive applies another decoder to an array of values.\n\n```typescript\narray(string).decodeJson('[\"foo\", \"bar\"]'); // --> Ok([\"foo\", \"bar\"])\narray(string).decodeJson('[\"foo\", 42]'); // --> Err(\"42 is not a string\")\n```\n\n## objects\n\nThe `field` and `at` decoders are used to extract values from objects.\n\n```typescript\nfield('bar', string).decodeAny({ bar: 'baz' }); // --> Ok('baz')\nat(['foo', 0, 'bar'], number).decodeAny({ foo: [{ bar: 42 }] }); // --> Ok(42)\n```\n\nObject decoders can be chained together to build more complex data structures.\n\n```typescript\n// prettier-ignore\nfield('userId', number).andThen(id =>\nfield('emailAddress', string).andThen(email =>\nsucceed({ id, email })))\n.decodeAny({ userId: 213, emailAddress: 'foo@example.com' })\n// --> Ok({ id: 213, email: 'foo@example.com'})\n```\n\nOf course, your code editor may try to reformat this code.\n\n```typescript\nfield('userId', number)\n  .andThen((id) =>\n    field('emailAddress', string).andThen((email) => succeed({ id, email }))\n  )\n  .decodeAny({ userId: 213, emailAddress: 'foo@example.com' });\n// --> Ok({ id: 213, email: 'foo@example.com'})\n```\n\nFor an object of any moderate complexity, this nesting is indistinguishable from\ncallback hell.\n\nTo combat this, decoders have a method named `assign`. It enacapsulates this\npattern of building objects such that objects can be built incrementally, without\nnesting and without losing type safety.\n\nThe previous example would look like this using `assign`:\n\n```typescript\nsucceed({})\n  .assign('id', field('userId', number))\n  .assign('email', field('emailAddress', string))\n  .decodeAny({ userId: 213, emailAddress: 'foo@example.com' });\n// --> Ok({ id: 213, email: 'foo@example.com' })\n```\n\nThe best strategy for handling object construction with decoders\nis to compose complex decoders from smaller, simpler decoders.\n\n```typescript\nsucceed({})\n  .assign('user', field('user', userDecoder))\n  .assign('courses', at(['student', 'courses'], array(courseDecoder)))\n  .decodeJson('... some json ... ')\n\nconst userDecoder = //...\nconst courseDecoder = //...\n```\n\n# docs\n\n[API](https://kofno.github.io/jsonous)\n"}},"__N_SSG":true}