{"pageProps":{"packageData":{"slug":"ajaxian","metadata":{"name":"ajaxian","description":"Ajax requests with better error handling"},"readme":"# ajaxian\n\n[![Build Status](https://travis-ci.org/kofno/ajaxian.svg?branch=master)](https://travis-ci.org/kofno/ajaxian)\n[![semantic-release](https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg?style=flat-square)](https://github.com/semantic-release/semantic-release)\n\nAjaxian is a small wrapper around the XMLHttpRequest object. It borrows heavily\nfrom the Elm Http module. In many ways it's not all that different from other\nhttp libraries: build a request, send it to the server, and then handle the\nresponse. The emphasis here is on handling error responses correctly and\nconsistently, without resorting to thrown exceptions.\n\nBecause it uses XMLHttpRequest, Ajaxian can only be used from the browser (or\na browser-like environment, like Electron). Browserify, Webpack, or some similar\ntool may be required when packaging for deploy.\n\n## tasks\n\nInstead of Promises, Ajaxian uses Futures (here called Tasks, from the\nTaskarian library). Tasks are lazy and will not execute until forked. This\nmeans a Task can be returned from a pure function. Tasks are also composable.\nYou can build a complex chain of behaviors, while strictly controlling exactly\nwhen the side effects happen. In this way I prefer them over Promises, which\nare stateful and initiate side effects as soon as they are instantiated.\n\n## errors\n\nAjaxian does not throw errors for failed requests. Instead, failed requests\nare returned as one of several different types of errors. Error conditions\nare documented this way because I believe that you create a better user\nexperience when you handle error conditions gracefully. I want to provide\nthe tools for doing that.\n\nAll of the error types are documented in the HttpError module.\n\n## decoders\n\nDecoders are another idea stolen from Elm. A decoder is a function that converts\nthe response body of a request into a data structure that can be used by the\napplication.\n\nAjaxian expects the decoder to return the results wrapped in a Result object.\nIf the data passes muster, then the decoder should return the data wrapped in\nan Ok object. If the data is incorrect, then an error message wrapped will be\nwrapped in an Err object. This will result in a BadPayload error.\n\nIf you are building a json heavy application, I would recommend checking out\n[jsonous](https://github.com/kofno/jsonous). This library is specifically\nbuilt for creating composable decoders for handling json content.\n\n# installing\n\n> npm install --save ajaxian\n\n> yarn add ajaxian\n\n# usage\n\n    import { toHttpTask, Request, header } from 'ajaxian';\n    import { ok } from 'resulty';\n\n    // Create a request object. This is a TS example.\n    const request: Request<{}> = {\n      url: '/some_end_point',\n      method: 'post',\n      data: { foo: 'bar' },\n      timeout: 0,\n      headers: [header('X-Some-Header', 'baz')],\n      withCredentials: true,\n      decoder: () => ok({}),\n    };\n\n    toHttpTask(request).fork(\n      err => console.error(err),\n      data => console.log(\"Success!\", data)\n    );\n\nThere are some convenience builders for making requests, too:\n\n    import { post } from 'ajaxian';\n\n    const request = post('/some_end_point', { foo: bar }, () => ok({}))\n      .withHeader(header('X-Some-Header', 'baz'));\n\nIt is also possible to abort an HTTP request before it completes. Forking the\nHTTP task returns an abort function from the underlying HTTP request object:\n\n    const cancel = toHttpTask(request).fork(\n      err => console.error(err),\n      data => console.log(\"Success!\", data),\n    );\n\n    cancel() // <-- aborts request\n"}},"__N_SSG":true}