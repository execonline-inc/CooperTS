{"pageProps":{"packageData":{"slug":"decoders","metadata":{"name":"@execonline-inc/decoders","description":"Generally useful decoders that extend Jsonous"},"readme":"# `decoders`\n\nThe `decoders` package provides useful utility decoder implementations.\n\n```ts\nimport * as decoders from '@execonline-inc/decoders';\n\nimport Decoder, { fail, field, succeed } from 'jsonous';\nimport { fromEmpty, Maybe } from 'maybeasy';\nimport { Result } from 'resulty';\n```\n\n## Functions\n\n### `eql`, `stringLiteral`\n\nThe `eql` decoder decodes for a specific value rather than some type. The `stringLiteral` decoder is an application of the `eql` decoder for just `string` values.\n\n```ts\nimport { eql } from '@execonline-inc/decoders';\nimport Decoder from 'jsonous';\nimport { Result } from 'resulty';\n\nconst example: Decoder<123> = eql<123>(123);\nconst result: Result<string, 123> = example.decodeAny(123);\n```\n\n```ts\nimport { stringLiteral } from '@execonline-inc/decoders';\nimport Decoder from 'jsonous';\nimport { Result } from 'resulty';\n\nconst example: Decoder<'abc'> = stringLiteral('abc');\nconst result: Result<string, 'abc'> = example.decodeAny('abc');\n```\n\n### `regexDecoder`\n\n```ts\nimport { regexDecoder } from '@execonline-inc/decoders';\nimport Decoder, { fail, succeed } from 'jsonous';\n\nconst example: Decoder<string> = regexDecoder(/(abc)/).andThen(result =>\n  fromEmpty(result[1]).map(str => succeed(str).getOrElse(() => fail('Could not find \"abc\"')))\n);\n```\n\n### `nullableBlankString`\n\nThis decoder handles a value that should be a string but could also be `null` or `undefined` and converts it to a `Maybe`.\n\n```ts\nimport { nullableBlankString } from '@execonline-inc/decoders';\nimport Decoder from 'jsonous';\nimport { Result } from 'resulty';\n\nconst example: Decoder<Maybe<string>> = nullableBlankString;\nconst result: Result<string, Maybe<string>> = example.decodeAny('abc');\n```\n\n### `base64Decoder`\n\nThis decoder decodes input as base64 using the browser's `atob` function. A decoder error is the result from any thrown errors.\n\n```ts\nimport { base64Decoder } from '@execonline-inc/decoders';\nimport Decoder from 'jsonous';\nimport { Result } from 'resulty';\n\nconst example: Decoder<string> = base64Decoder;\nconst result: Result<string, string> = example.decodeAny('aGVsbG8=');\n```\n\n### `jsonParserDecoder`\n\nThis decoder takes a decoder whose output is parsed as JSON. If JSON parsing fails, then a decoder error is the result.\n\n```ts\nimport { base64Decoder, jsonParserDecoder } from '@execonline-inc/decoders';\nimport Decoder from 'jsonous';\nimport { Result } from 'resulty';\n\nconst example: Decoder<string> = jsonParserDecoder(base64Decoder);\nconst result: Result<string, string> = example.decodeAny('ImhlbGxvIg==');\n```\n\n### `pipeD`\n\nThis decoder is used to run two decoders in sequence passing the successfully decoded value from the first as the input for the second.\n\n```ts\nimport { base64Decoder, pipeD, stringLiteral } from '@execonline-inc/decoders';\nimport Decoder from 'jsonous';\nimport { Result } from 'resulty';\n\nconst example: Decoder<'hello'> = pipeD(base64Decoder, stringLiteral('hello'));\nconst result: Result<string, string> = example.decodeAny('aGVsbG8=');\n```\n\n### `numberToStringDecoder`\n\n```ts\nimport { numberToStringDecoder } from '@execonline-inc/decoders';\nimport Decoder from 'jsonous';\nimport { Result } from 'resulty';\n\nconst example: Decoder<string> = numberToStringDecoder;\nconst result: Result<string, string> = example.decodeAny(123);\n```\n\n### `stringToNumberDecoder`\n\n```ts\nimport { stringToNumberDecoder } from '@execonline-inc/decoders';\nimport Decoder from 'jsonous';\nimport { Result } from 'resulty';\n\nconst example: Decoder<number> = stringToNumberDecoder;\nconst result: Result<string, number> = example.decodeAny('123');\n```\n\n### `jsonValueDecoder`\n\nTODO\n\n### `secondsDecoder`\n\n```ts\nimport { secondsDecoder } from '@execonline-inc/decoders';\nimport Decoder from 'jsonous';\nimport { Result } from 'resulty';\n\nconst example: Decoder<Time> = secondsDecoder;\nconst result: Result<string, Time> = example.decodeAny(60);\n```\n\n### `explicitJust`\n\nThis is used to decode a JSON object representing a `Maybe` monad that's expected to be a `Just`:\n\n```ts\nimport { explicitJust } from '@execonline-inc/decoders';\nimport Decoder from 'jsonous';\nimport { Result } from 'resulty';\n\nconst thing = { kind: 'just', value: 123 };\nconst example: Decoder<Maybe<number>> = explicitJust;\nconst result: Result<string, Maybe<number>> = example.decodeAny(thing);\n```\n\n### `explicitNothing`\n\nThis is used to decode a JSON object representing a `Maybe` monad that's expected to be a `Nothing`:\n\n```ts\nimport { explicitNothing } from '@execonline-inc/decoders';\nimport Decoder from 'jsonous';\nimport { Result } from 'resulty';\n\nconst thing = { kind: 'nothing' };\nconst example: Decoder<Maybe<number>> = explicitNothing;\nconst result: Result<string, Maybe<number>> = example.decodeAny(thing);\n```\n\n### `explicitMaybe`\n\nThis is used to decode a JSON object representing a `Maybe` monad that could be either a `Just` or a `Nothing`.\n\n### `mergeObjectDecoders`\n\nThis will produce a single decoder by combining the decoded fields of the two given decoders.\n\nIf the given decoders overlap for any fields, the second decoder will decide the final value for those fields.\n\n```ts\nimport { mergeObjectDecoders, stringLiteral } from '@execonline-inc/decoders';\nimport Decoder, { field } from 'jsonous';\nimport { Result } from 'resulty';\n\ninterface A {\n  foo: string;\n  bar: string;\n}\ninterface B {\n  bar: 'star';\n  baz: 'jazz';\n}\n\nconst objA: A = { foo: 'goo', bar: 'car' };\nconst objB: B = { bar: 'star', baz: 'jazz' };\n\nconst decoderA: Decoder<A> = succeed({})\n  .assign('foo', field('foo', string))\n  .assign('bar', field('bar', string));\nconst decoderB: Decoder<B> = succeed({})\n  .assign('bar', field('bar', stringLiteral('star')))\n  .assign('baz', field('baz', stringLiteral('jazz')));\n\nconst example: Decoder<A & B> = mergeObjectDecoders(decoderA, decoderB);\nconst result: Result<string, A & B> = example.decodeAny({ ...objA, ...objB });\n```\n"}},"__N_SSG":true}