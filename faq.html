<!DOCTYPE html><html class="dark js-focus-visible antialiased [font-feature-settings:&#x27;ss01&#x27;]" lang="en"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>FAQs | CooperTS</title><meta name="next-head-count" content="3"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin /><link rel="preload" href="/_next/static/css/8e98d0211ff5ae13.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8e98d0211ff5ae13.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-5752944655d749a0.js" defer=""></script><script src="/_next/static/chunks/framework-76d02cbefae1782a.js" defer=""></script><script src="/_next/static/chunks/main-b92974553887b4ef.js" defer=""></script><script src="/_next/static/chunks/pages/_app-ce3d904eec922fd1.js" defer=""></script><script src="/_next/static/chunks/pages/faq-e27c561020c4766b.js" defer=""></script><script src="/_next/static/RrKv9ioTm-oJIK2k8EiP8/_buildManifest.js" defer=""></script><script src="/_next/static/RrKv9ioTm-oJIK2k8EiP8/_ssgManifest.js" defer=""></script><script src="/_next/static/RrKv9ioTm-oJIK2k8EiP8/_middlewareManifest.js" defer=""></script><style data-href="https://fonts.googleapis.com/css2?family=Atkinson+Hyperlegible:ital,wght@0,400;0,700;1,400;1,700&display=swap">@font-face{font-family:'Atkinson Hyperlegible';font-style:italic;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/atkinsonhyperlegible/v10/9Bt43C1KxNDXMspQ1lPyU89-1h6ONRlW45G055Iu.woff) format('woff')}@font-face{font-family:'Atkinson Hyperlegible';font-style:italic;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/atkinsonhyperlegible/v10/9Bt93C1KxNDXMspQ1lPyU89-1h6ONRlW45G056qRdiWJ.woff) format('woff')}@font-face{font-family:'Atkinson Hyperlegible';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/atkinsonhyperlegible/v10/9Bt23C1KxNDXMspQ1lPyU89-1h6ONRlW45GE5g.woff) format('woff')}@font-face{font-family:'Atkinson Hyperlegible';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/atkinsonhyperlegible/v10/9Bt73C1KxNDXMspQ1lPyU89-1h6ONRlW45G8WbcNcA.woff) format('woff')}@font-face{font-family:'Atkinson Hyperlegible';font-style:italic;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/atkinsonhyperlegible/v10/9Bt43C1KxNDXMspQ1lPyU89-1h6ONRlW45G056IkUwCgblWmLWQ.woff2) format('woff2');unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Atkinson Hyperlegible';font-style:italic;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/atkinsonhyperlegible/v10/9Bt43C1KxNDXMspQ1lPyU89-1h6ONRlW45G056IqUwCgblWm.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'Atkinson Hyperlegible';font-style:italic;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/atkinsonhyperlegible/v10/9Bt93C1KxNDXMspQ1lPyU89-1h6ONRlW45G056qRdhWDTFiMF225Z2k.woff2) format('woff2');unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Atkinson Hyperlegible';font-style:italic;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/atkinsonhyperlegible/v10/9Bt93C1KxNDXMspQ1lPyU89-1h6ONRlW45G056qRdhWNTFiMF225.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'Atkinson Hyperlegible';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/atkinsonhyperlegible/v10/9Bt23C1KxNDXMspQ1lPyU89-1h6ONRlW45G07JIoWQeCbGWn.woff2) format('woff2');unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Atkinson Hyperlegible';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/atkinsonhyperlegible/v10/9Bt23C1KxNDXMspQ1lPyU89-1h6ONRlW45G04pIoWQeCbA.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'Atkinson Hyperlegible';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/atkinsonhyperlegible/v10/9Bt73C1KxNDXMspQ1lPyU89-1h6ONRlW45G8Wbc9eiWPRl-uFV24.woff2) format('woff2');unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Atkinson Hyperlegible';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/atkinsonhyperlegible/v10/9Bt73C1KxNDXMspQ1lPyU89-1h6ONRlW45G8Wbc9dCWPRl-uFQ.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}</style></head><body class="prose prose-slate bg-white prose-lead:text-slate-500 prose-a:font-bold prose-a:no-underline prose-a:text-sky-500 max-w-full prose-a:shadow-[inset_0_17px_0_0_var(--tw-prose-background,#fff),inset_0_calc(-1*(var(--tw-prose-underline-size,4px)+2px))_0_0_var(--tw-prose-underline,theme(colors.sky.300))] hover:prose-a:[--tw-prose-underline-size:6px] dark:prose-invert dark:bg-slate-900 dark:text-slate-400 dark:[--tw-prose-background:theme(colors.slate.900)] dark:prose-lead:text-slate-400 dark:prose-a:text-sky-400 dark:prose-a:shadow-[var(--darkProseAShadow)] dark:hover:prose-a:[--tw-prose-underline-size:3px] dark:prose-hr:border-slate-800"><div id="__next"><div class="flex h-screen w-screen flex-col justify-between scroll-smooth"><header class="not-prose sticky top-0 z-50 flex items-center justify-between space-x-6 bg-white py-3 shadow-md shadow-slate-900/5 transition duration-500 dark:shadow-none sm:space-x-10 sm:py-4 md:py-5 dark:bg-transparent"><div class="content-container-width mx-auto py-3 flex items-center justify-between space-x-6"><a class="text-base font-bold text-green-600 hover:text-indigo-900 dark:text-green-300 dark:hover:text-indigo-300 sm:text-lg" href="/">CooperTS</a><nav class="md:text-md flex items-center space-x-5 text-sm sm:space-x-10 sm:text-sm" aria-label="Primary"><a class="font-medium text-gray-600 hover:text-gray-900 dark:text-gray-300 dark:hover:text-white" href="/about">About</a><a class="font-medium text-gray-600 hover:text-gray-900 dark:text-gray-300 dark:hover:text-white" href="/guide">Guide</a><a class="font-medium text-gray-600 hover:text-gray-900 dark:text-gray-300 dark:hover:text-white" href="/packages">Packages</a><a class="font-medium text-gray-600 hover:text-gray-900 dark:text-gray-300 dark:hover:text-white" href="/examples">Examples</a><a class="font-medium text-gray-600 hover:text-gray-900 dark:text-gray-300 dark:hover:text-white" href="/faq">FAQs</a><a class="group" href="https://github.com/execonline-inc/CooperTS"><span class="sr-only">CooperTS on GitHub</span><svg aria-hidden="true" viewBox="0 0 16 16" class="h-6 w-6 fill-slate-500 group-hover:fill-slate-700 dark:fill-slate-300 dark:group-hover:fill-white"><path d="M8 0C3.58 0 0 3.58 0 8C0 11.54 2.29 14.53 5.47 15.59C5.87 15.66 6.02 15.42 6.02 15.21C6.02 15.02 6.01 14.39 6.01 13.72C4 14.09 3.48 13.23 3.32 12.78C3.23 12.55 2.84 11.84 2.5 11.65C2.22 11.5 1.82 11.13 2.49 11.12C3.12 11.11 3.57 11.7 3.72 11.94C4.44 13.15 5.59 12.81 6.05 12.6C6.12 12.08 6.33 11.73 6.56 11.53C4.78 11.33 2.92 10.64 2.92 7.58C2.92 6.71 3.23 5.99 3.74 5.43C3.66 5.23 3.38 4.41 3.82 3.31C3.82 3.31 4.49 3.1 6.02 4.13C6.66 3.95 7.34 3.86 8.02 3.86C8.7 3.86 9.38 3.95 10.02 4.13C11.55 3.09 12.22 3.31 12.22 3.31C12.66 4.41 12.38 5.23 12.3 5.43C12.81 5.99 13.12 6.7 13.12 7.58C13.12 10.65 11.25 11.33 9.47 11.53C9.76 11.78 10.01 12.26 10.01 13.01C10.01 14.08 10 14.94 10 15.21C10 15.42 10.15 15.67 10.55 15.59C13.71 14.53 16 11.53 16 8C16 3.58 12.42 0 8 0Z"></path></svg></a></nav></div></header><main class="fixed-origin content-container-width relative mx-auto flex flex-col justify-center"><div class="not-prose relative lg:block lg:flex-none"><div class="sticky top-[4.5rem] -ml-0.5 h-[calc(100vh-4.5rem)] overflow-y-auto py-16 pl-0.5"><nav class="w-64 pr-8 text-base lg:text-sm xl:w-72 xl:pr-16" aria-labelledby="secondary-nav-header"><ul class="space-y-9"><li><h1 class="font-display font-medium text-slate-900 dark:text-white" id="secondary-nav-header">Frequently Asked Questions</h1><ul class="not-prose lg:border-slate-20 mt-6 space-y-2 border-l-2 border-slate-100 dark:border-slate-800 lg:mt-4 lg:space-y-4"><li class="relative"><a class="block w-full pl-3.5 text-slate-500 before:pointer-events-none before:absolute before:-left-1 before:top-1/2 before:hidden before:h-1.5 before:w-1.5 before:-translate-y-1/2 before:rounded-full before:bg-slate-300 hover:text-slate-600 hover:before:block dark:text-slate-400 dark:before:bg-slate-700 dark:hover:text-slate-300" href="/faq/about-map">What&#x27;s All This About Map Then?</a></li><li class="relative"><a class="block w-full pl-3.5 text-slate-500 before:pointer-events-none before:absolute before:-left-1 before:top-1/2 before:hidden before:h-1.5 before:w-1.5 before:-translate-y-1/2 before:rounded-full before:bg-slate-300 hover:text-slate-600 hover:before:block dark:text-slate-400 dark:before:bg-slate-700 dark:hover:text-slate-300" href="/faq/billion-dollar-mistake">Avoiding The Billion Dollar Mistake</a></li><li class="relative"><a class="block w-full pl-3.5 text-slate-500 before:pointer-events-none before:absolute before:-left-1 before:top-1/2 before:hidden before:h-1.5 before:w-1.5 before:-translate-y-1/2 before:rounded-full before:bg-slate-300 hover:text-slate-600 hover:before:block dark:text-slate-400 dark:before:bg-slate-700 dark:hover:text-slate-300" href="/faq/getorelse-vs-getorelsevalue">When to Use Which - getOrElse vs getOrElseValue</a></li><li class="relative"><a class="block w-full pl-3.5 text-slate-500 before:pointer-events-none before:absolute before:-left-1 before:top-1/2 before:hidden before:h-1.5 before:w-1.5 before:-translate-y-1/2 before:rounded-full before:bg-slate-300 hover:text-slate-600 hover:before:block dark:text-slate-400 dark:before:bg-slate-700 dark:hover:text-slate-300" href="/faq/imperative-vs-declarative">Imperative vs Declarative Programming</a></li><li class="relative"><a class="block w-full pl-3.5 text-slate-500 before:pointer-events-none before:absolute before:-left-1 before:top-1/2 before:hidden before:h-1.5 before:w-1.5 before:-translate-y-1/2 before:rounded-full before:bg-slate-300 hover:text-slate-600 hover:before:block dark:text-slate-400 dark:before:bg-slate-700 dark:hover:text-slate-300" href="/faq/map-vs-andthen">When To Use Which - map vs. andThen</a></li><li class="relative"><a class="block w-full pl-3.5 text-slate-500 before:pointer-events-none before:absolute before:-left-1 before:top-1/2 before:hidden before:h-1.5 before:w-1.5 before:-translate-y-1/2 before:rounded-full before:bg-slate-300 hover:text-slate-600 hover:before:block dark:text-slate-400 dark:before:bg-slate-700 dark:hover:text-slate-300" href="/faq/monads">When To Use Which - Maybe vs Result vs Task (and other Monads)</a></li></ul></li></ul></nav></div></div></main><div class="fixed bottom-0 right-0 z-[10000] flex h-auto w-auto items-center justify-center p-1  text-sm font-bold text-white dark:text-slate-900 rounded-full bg-slate-800 sm:bg-red-900 md:bg-blue-800 lg:bg-green-800 xl:bg-amber-600"><div class="inline-flex sm:hidden">xs (default)</div><div class="hidden sm:inline-flex md:hidden">SM</div><div class="hidden md:inline-flex lg:hidden">MD</div><div class="hidden lg:inline-flex xl:hidden">LG</div><div class="hidden xl:inline-flex">XL</div></div><footer class="not-prose sticky top-0 z-50 
        flex flex-wrap items-center justify-between
        bg-white
        py-5 px-4 shadow-md
        shadow-slate-900/5 
        dark:bg-slate-900/95 dark:shadow-none
        sm:px-6 lg:px-8" aria-label="footer"><p>© <!-- -->2022 <!-- --><a href="https://www.execonline.com/" target="_blank" rel="noopener noreferrer">ExecOnline</a></p></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"pages":[{"slug":"about-map","frontmatter":{"title":"What's All This About Map Then?","description":""},"markdown":{"content":"\n## Caveats and Disclaimers\n\nI make no guarantees that the code examples compile or execute. All code examples are syntactically similar to Typescript, but should be treated as pseudo-code. Also, I expect to reference behaviors (methods, etc) that actually don't exist in the JavaScript standard library (though it'd be nice if some of them did). I try to call out where I'm doing this, but really who knows if I got every case. The intent of this is not because I'm lazy (well, not exclusively because I'm lazy), but because I want to emphasize the concepts, and not muddy the waters of learning with the intricacies of the JavaScript implementation reality.\n\nWith that out of the way, on to the topic at hand...\n\n## But First... (a Pure Function Primer)\n\nBefore we tackle Map and AndThen, we should make sure that we are all on the same page about functions.\n\nIn the mathematical sense, a function is just a mapping from a Set of inputs to a Set of outputs. The output for any given input will always be the same. In the programming world, we call these functions \"pure\" functions. and they are becoming quite popular.\n\nPure functions are defined by having no side effects and always returning the same value for the same arguments.This idea is often called \"referential integrity\", which simply means that if you replace your function call with the value returned from the function, your program doesn't break.\n\nLet's take a moment to explore referential integrity. Given this function:\n\n### add2\n\n```typescript\nconst add2 = (n: number) =\u003e n + 2;\n```\n\nThen this program:\n\n### referential program 1\n\n```typescript\nadd2(2) === 4;\n```\n\nis identical to this program:\n\n### referential program 2\n\n```typescript\n4 === 4;\n```\n\nSo.. that was probably a tad underwhelming.\n\nNow let's consider a slightly different version of add2.\n\n### side effectual add2\n\n```typescript\nconst add2 = (n: number) =\u003e {\n  sendEngagement(`Someone added 2 to ${n}`);\n  return n + 2;\n};\n```\n\nNow when I replace add2(2) === 4 with 4 === 4, how many Product Managers am I going to have in my inbox in the morning because the add2 engagements are broken? Imagine trying to write tests for both versions of add2. Which one is easier?\n\nThe problem with the second version of add2 is that has side effects in addition to the computation we were expecting. Side effects could include mutating inputs, modifying global variables, I/O operations (reading writing to disk, http requests, reading environment variables, etc.). You can't have a meaningful program without side-effects, but a key tenant of CooperTS is that we want to separate our side effects from our business logic. This makes the business logic easier to write and understand, while isolating parts of the code that are going to fail at runtime.\n\nSo why did we go through all this just to talk about Map and AndThen? Well, the laws that govern how Map and AndThen work assume that the functions that are passed in are pure. Applying side effectual behaviors using Map and AndThen are generally discouraged as they subvert optimizations and logic that the mapping behavior is applying in the implementation. Map, after, all isn't just a stylistic preference for looping.\n\nWith all that out of the way, let's look at Map and AndThen as applied to Arrays.\n\n## The Array\n\nSo let's look at a map in the familiar context of an Array.\n\nBefore we begin, let's define some types to work with:\n\n### Types.ts\n\n```typescript\ninterface Encoding {\n  id: string;\n  name: string;\n}\n\ninterface Stream {\n  id: string;\n  codec: string;\n}\n\ninterface Video {\n  encoding: Encoding;\n  streams: Stream[]\n}\n\nconst videos: Video[] = // ... assume we initialized this array with videos\n```\n\nNow lets write a couple loops. One that gets all of the encoding ids from the list of videos, and another that gets all the stream ids from the list of videos:\n\n### Get you some encoding ids\n\n```typescript\nconst encodingIds: string[] = [];\n\nfor (let i = 0; i \u003c videos.length; i++) {\n  const id = videos[i].encoding.id;\n  encodingIds.push(id);\n}\n\nconst streamIds: string[] = [];\n\nfor (let i = 0; i \u003c videos.length; i++) {\n  const streams = videos[i].streams;\n\n  for (let j = 0; j \u003c streams.length; j++) {\n    const id = streams[j].id;\n    streamIds.push(id);\n  }\n}\n```\n\nIf you read this code honestly, you have to admit that it's mostly loop management and state initialization; low level concepts that muddy up our business concerns.\n\nNow let's extract the \"business logic\" into some functions:\n\n### Functions.ts\n\n```typescript\nconst getId = \u003cT extends { id: string }\u003e(thing: T): string =\u003e thing.id;\n\nconst getStreams = (video: Video): Stream[] =\u003e video.streams;\n\nconst getEncoding = (video: Video): Encoding =\u003e video.encoding;\n```\n\nAnd we'll try again:\n\n### Loops redeux\n\n```typescript\nconst encodingIds: string[] = [];\n\nfor (let i = 0; i \u003c videos.length; i++) {\n  const id = getId(getEncoding(videos[i]));\n  encodingIds.push(id);\n}\n\nconst streamIds: string[] = [];\n\nfor (let i = 0; i \u003c videos.length; i++) {\n  const streams = getStreams(videos[i]);\n\n  for (let j = 0; j \u003c streams.length; j++) {\n    const id = getId(streams[j]);\n    streamIds.push(id);\n  }\n}\n```\n\nIs this better? Well, each piece of business logic is much easier to test now. But we're still doing loop maintenance and state management, and depending on how you feel about reading functions vs. dot notation, this might be harder for you to read.\n\nLet's look again at the encoding ids example, this time using map:\n\n### Encoding IDs, Mapped edition\n\n```typescript\nconst encodingIds: string[] = videos.map(getEncoding).map(getId);\n```\n\nAnd that's all she wrote. Loop maintenance is gone. State management is gone. All that's left are the declarations of what the logic is doing.\n\n\"So tell me...\", you may be thinking. \"How does map work?\"\n\nLet us now take a look at a hypothetical implementation of map in a hypothetical Array class:\n\n### Map's Guts\n\n```typescript\nclass Array\u003cA\u003e {\n  //... a bunch of stuff that makes arrays arrays\n  map = \u003cB\u003e(fn: (a: A) =\u003e B): Array\u003cB\u003e =\u003e {\n    const newArray: B[] = [];\n\n    for (let i = 0; i \u003c this.length; i++) {\n      const b = fn(this[i]);\n      newArray.push(b);\n    }\n\n    return newArray;\n  };\n}\n```\n\nSo that's where all the loop maintenance and state management went!? Indeed. This is the power of map: It abstracts away low level considerations, and surfaces only the business concerns.\n\nNow I want to take a look at the signature of the fn argument in map and compare it to our business logic functions:\n\n### Map Signature\n\n```typescript\nfn: (a: A) =\u003e B\n\ngetId: (thing: T): string\n\ngetStreams: (video: Video): Stream[]\n\ngetEncoding: (video: Video): Encoding\n```\n\nEvery single one of our business logic functions is compatible with map. And this will be true of any pure function. As long as it takes a single argument (or can be curried down to take a single argument) then that function can be used with map. And we can see in the array example that map frees up a lot of mental bandwidth, freeing up cycles that were once devoted to tracking loop and state details but can now be applied to solving actual application space problems.\n\nThis idea of map abstracting away low level details is powerful. In the array, it hides looping and state mutation. But imagine if all of your ugly, side effectual, state management details could be modeled as mappable data structures. In that world, all of your business logic could be written in easily tested, easily reasoned about, type checkable, pure functions. No mocks. No browser. No environment considerations. WOW!\n\nOf course, when everything seems rosy, there's always something that comes along and throws a wrench in the works. Let's see what happens when we apply map the stream ids case:\n\n### map stream ids\n\n```typescript\nconst streamIds: string[] = videos.map(getStreams).map((streams) =\u003e streams.map(getId));\n```\n\nUgh... getStreams is breaking my beautiful code. Since it returns an array, I have to nest a map inside another map; abstraction details are leaking out. Also, this won't compile because I've declared that I need a string[], but I'm actually getting a string[][]. Ay caramba!\n\nWe could fix the compiler error with something intensely JavaScripty, like this:\n\n### Intense JavaScript\n\n```typescript\nconst tempStreamIds: string[][] = videos.map(getStreams).map((streams) =\u003e streams.map(getId));\n\nconst streamIds: string[] = [].concat.apply([], tempStreamIds);\n```\n\nIt should compile now, but so help me... I need to know how JavaScript functions can be applied; the lowest of low level details. Calgon, take me away.\n\nWhat would be great here, is if we had a function like map, but instead of appending the results of the map function (fn), it concatenated them. What would we call such a function? How about concatMap? Let's look at a hypothetical implementation of concatMap:\n\n### concatMap\n\n```typescript\nclass Array\u003cA\u003e {\n  //... a bunch of stuff that makes arrays arrays\n  concatMap = \u003cB\u003e(fn: (a: A) =\u003e B[]): Array\u003cB\u003e =\u003e {\n    let newArray: B[] = [];\n\n    for (let i = 0; i \u003c this.length; i++) {\n      const bs = fn(this[i]);\n      newArray = newArray.concat(bs);\n    }\n\n    return newArray;\n  };\n}\n```\n\nHeavens to Betsy, that looks a lot like map, doesn't it? The differences are that the fn function argument must return an array, and those arrays are being concatenated, rather then appended.\n\nWell, now that we have concatMap, let's go back and fix our streamIds:\n\n### fixed stream ids\n\n```typescript\nconst streamIds: string[] = videos.concatMap(getStreams).map(getId);\n```\n\nPhew... that is so much nicer.\n\nIn this section we've seen that map and it's close sibling concatMap are incredibly handy abstractions to have around. They de-emphasize low level details allowing us to re-emphasize business logic. In many cases, that leads to purely functional application logic that is easily tested and easily reasoned about.\n\nThat's a lot to take in. Why don't we take a break here and enjoy a Blueberry Acai Diet Coke before moving on to the next section?\n\n## Walk-thru of Map\n\nTo make sure we clearly understand what is going on here, let's walk through the map implementation for arrays. Here is the code again...\n\n### Map's Guts\n\n```typescript\nclass Array\u003cA\u003e {\n  //... a bunch of stuff that makes arrays arrays\n  map = \u003cB\u003e(fn: (a: A) =\u003e B): Array\u003cB\u003e =\u003e {\n    const newArray: B[] = [];\n\n    for (let i = 0; i \u003c this.length; i++) {\n      const b = fn(this[i]);\n      newArray.push(b);\n    }\n\n    return newArray;\n  };\n}\n```\n\nLine 4: When we enter into map, the first thing that happens is a new Array is instantiated.\n\nLine 7: Then, we apply fn to each item in the array.\n\nLine 8: The result of that function call is appended to the new array.\n\nLine 11. Then we return the new array.\n\nIn the case where the array is empty, the looping logic falls through and we simply return the new, empty array.\n\n## Walk-thru of concatMap\n\nNow we'll do the same walk through, but with concatMap. Here's the code again:\n\n### concatMap\n\n```typescript\nclass Array\u003cA\u003e {\n  //... a bunch of stuff that makes arrays arrays\n  concatMap = \u003cB\u003e(fn: (a: A) =\u003e B[]): Array\u003cB\u003e =\u003e {\n    let newArray: B[] = [];\n\n    for (let i = 0; i \u003c this.length; i++) {\n      const bs = fn(this[i]);\n      newArray = newArray.concat(bs);\n    }\n\n    return newArray;\n  };\n}\n```\n\nLine 4: When we enter into concatMap, we start by create a new array (same as with map)\n\nLine 7: Then we apply fn to each item in the array. In the case of concatMap, the result from fn will be another array.\n\nLine 8: Next we concatenate the array from line 7, onto the new array that we are constructing.\n\nLine 11: Finally, we return our new array, which is flattened out without any nesting.\n\nIn the case where the array is empty, the loop logic falls through and the empty array is returned.\n\n## Other Mappable Types\n\nWe can now take this understanding of map and concatMap and apply it to other mappable types. For example, let's create a data type that represents an optional value. This is a type that can replace the use of undefined. It encapsulates checks for undefined in one place, and makes it possible to cleanly chain together computations on values that may or may not be available.\n\nLet's start with a simple class definition for Optional:\n\n```typescript\nclass Optional\u003cA\u003e {\n  public static some = \u003cA\u003e(value: A) =\u003e {\n    return new Optional\u003cA\u003e(value);\n  };\n\n  public static none = \u003cA\u003e() =\u003e {\n    return new Optional\u003cA\u003e();\n  };\n\n  private value?: A;\n\n  private constructor(value?: A) {\n    this.value = value;\n  }\n\n  // ... more to come\n}\n```\n\nThis class has a private value that could be undefined, or it could be some generic type of A.\n\nSo far we can construct some value or we can construct a none value, but since the value is private, we can't do anything with it. Let's add a map method first, so we can at least get at the value. As we read this code, try to keep the Array map intuition in mind. The None case is like having an empty array, and the Some case is like having a one item array. Let's write this:\n\n```typescript\nclass Optional\u003cA\u003e {\n  // ... constructors and stuff\n\n  map = \u003cB\u003e(fn: (a: A) =\u003e B) =\u003e {\n    return typeof this.value !== 'undefined' ? Optional.some(fn(this.value)) : Optional.none();\n  };\n}\n```\n\nBecause there is no looping construct here, this logic is a bit more direct. We check if the value is defined. If it is, we apply fn to the value and return it wrapped in a new some. Otherwise, we return none.\n\nThe concatMap implementation is equally direct.\n\n```typescript\nclass Optional\u003cA\u003e {\n  // ... constructors and stuff\n\n  concatMap = \u003cB\u003e(fn: (a: A) =\u003e Optional\u003cB\u003e) =\u003e {\n    return typeof this.value !== 'undefined' ? fn(this.value) : Optional.none();\n  };\n}\n```\n\nNow we can compose operations that may fail or return no results in the same way we could chain those calls to an array. For example:\n\n```typescript\nconst add =\n  (n1: number) =\u003e\n  (n2: number): n =\u003e {\n    return n1 + n2;\n  };\n\nconst safeDiv =\n  (dividend: number) =\u003e\n  (divisor: number): Optional\u003cnumber\u003e =\u003e {\n    return divisor === 0 ? Optional.none() : Optional.some(dividend / divisor);\n  };\n\nOptional.some(2).map(add(-2)).concatMap(safeDiv(4));\n```\n\nRather then producing NaN, this code will return None if the division fails (divide by zero error). That makes it easier to chain operations together.\n\n## Some Final Notes\n\nWe've demonstrated the logic behind map and concatMap in terms of Arrays, so that we can leverage that intuition and apply it to other mappable types. We've even looked at some hypothetical implementations of map and concatMap to help our understanding.\n\nWhen developing using CooperTS, our default optional value is actually called Maybe. But the logic and implementation details are applicable, only the names have been changed.\n\nAlso note, concatMap can be known by many names: bind, chain, flatMap,, \u003e\u003e=, etc. In CooperTS libraries like Maybeasy, Taskarain, and Jsonous, concatMap is named andThen.\n\nAnd now you know the rest of the story.\n"}},{"slug":"billion-dollar-mistake","frontmatter":{"title":"Avoiding The Billion Dollar Mistake","description":""},"markdown":{"content":"\nTony Hoare famously called NULL his \"billion dollar mistake\". In this post, we'll explore what null (and undefined) is, where it came from, and why we feel it is an inappropriate abstraction to use in modern business software development. We'll also explore how to program without null using CooperTS friendly libraries and patterns.\n\n## The Birth of NULL\n\n\u003e I call it my billion-dollar mistake. It was the invention of the null reference in 1965. At that time, I was designing the first comprehensive type system for references in an object oriented language (ALGOL W). My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn't resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.\n\u003e\n\u003e --- Tony Hoare (C.A.R. Hoare)\n\nNull references were originally created as a stand-in value for pointers that don't actually point to valid memory. This effectively breaks early type systems. Since the NULL reference can inhabit any types, the programmer is responsible for checking every single reference to ensure that it is not a NULL reference. So this puts the responsibility of safety and security into the hands of the programmers. regardless of their experience and motivation. In most programming languages, dereferencing a null pointer results in an immediate program crash. This is usually the result of one or more developer assumptions being violated (put a pin in that). This leads to reliability problems, but Null pointer exceptions can also be used by attackers to bypass security checks or produce a core dump, revealing details about the program that can aid future attacks.\n\nOver the years, many programming languages (Java, C#, etc,) have developed safe memory models to reduce the security risks of NULL pointer references, but many of those languages continue to allow NULL references to inhabit any type.\n\n## The Nullable Type\n\nSome programming languages don't specifically support a NULL reference, but instead implement a Nullable type. Ruby, for example, uses NilClass to represent the concept of NULL. A nullable type can be safely dereferenced, but as Ruby developers can attest, you still suffer from reliability problems. Sending an unsupported method to the nullable type still results in an immediate crash.\n\nMany programming languages that support Nullable types also support a \"safe\" dereference operator. Newer versions of Ruby (\u003e= 2.3), for example, use the \u0026. operator to allow any method to be safely sent to the NilClass object. The problem with this operator is that, while the program doesn't crash, an unexpected Nullable type still represents a violation of developer assumptions. So, while the program may not crash, there is likely still a bug. How this bug will ultimately manifest is undetermined.\n\n## The Null Object Pattern\n\nA user space extension of the Nullable Type that some OO programmers favor is the Null Object pattern. In this pattern, a stand-in object is used to represent the absence of a value. The stand-in object upholds the interface contract of whatever object it stands-in for. Null objects then act as a no-op for side-effectual method calls, and returns a sensible default value for query method calls. Implementing the Null Object pattern across a large code base can lead to a fairly complex object graph. If you decide to go all in on Null Objects, you need to implement Null Objects for all of your business objects and then you also need to keep your null objects implementations in sync with the actual implementation. This is often error prone and tedious.\n\nAnother side effect of the Null object pattern is that, from object oriented principles, the caller should not know if it has the Null Object or the real object. But some business decisions are based on knowing if you have Nothing or Something. In this case, you are back to needing to understand the difference between having nothing and having a real value.\n\n## The Optional Type\n\nThere is a significant impedance mismatch that comes from trying to use a low level memory abstraction to also represent a high level concept of a missing value. Some language developers (mostly typed languages) acknowledge this by NOT having NULL references and providing an Optional data type. This type is usually called Option or Maybe, depending on the language.\n\nOptional types make the concept of Nothing (None) an explicit and first class value. Any other type can be stored in an Optional type (integers, strings, object, arrays, etc.) And it provides a consistent and reliable interface for getting at the optional values and in the case where the value isn't available, operations against an optional type short circuit, resulting in... Nothing.\n\nOptional types can be composed through their functor or monad interfaces. They encapsulate the nothing checking so that the developer isn't required to remember to perform those checks. It also requires developers to explicitly declare when values can be optional or not, removing the risk that bugs will result from incorrect developer assumptions.\n\n## Rolling with Optional\n\nRather then relying on the leaky NULL abstraction, we prefer Optional types in CooperTS. It's an explicitly declared type who's intent is to express the concept of Nothing vs. Something. It is preferred for its consistent interface and for the security and reliability taking null checking out of the hands of developers.\n"}},{"slug":"getorelse-vs-getorelsevalue","frontmatter":{"title":"When to Use Which - getOrElse vs getOrElseValue","description":""},"markdown":{"content":"\nThe CooperTS monads have two options for extracting a value from the context; `getOrElseValue` and `getOrElse`. These are not interchangeable. Be careful when choosing which one to use.\n\n## getOrElseValue\n\nThis method is strict. The value passed to this is evaluated even if it is never needed. This option should be chosen for any value that is less expensive than an anonymous function and has no side effects.\n\nIn the context of React component rendering, choosing this can lead to bugs because you could be eagerly instantiating a component that may have side effects.\n\n## getOrElse\n\nThis method is lazy. The function passed to this is only evaluated when it is to be used. This is the option for any value that is more expensive than function construction or if the computation has side effects.\n"}},{"slug":"imperative-vs-declarative","frontmatter":{"title":"Imperative vs Declarative Programming","description":""},"markdown":{"content":"\n## Imperative\n\nImperative programming refers to a style of programming where programming statements change the state of the program. Imperative style is a bit of a leaky abstraction because it involves manipulating memory. Many developers prefer imperative programming because it appears to grant the developer more control over the execution of the program. It also tends to lead to an interleaving of lower level programming concepts (allocating memory) with higher level concepts (business rules). This can result in a hiding of the actual intent of the code.\n\nC, Java, JavaScript, etc. tend to be imperative programming languages.\n\n## Declarative\n\nDeclarative programming refers to a style of programming where higher level expressions describe the behavior of the program without describing the flow control. This style prevents the interleaving of business logic with lower level algorithmic concerns. This makes is easier to swap out implementations and improve the performance at a lower level, without touching the business logic. This valuable separation of concerns can lead to programs that are easier to understand and maintain.\n\nSQL is an example of a declarative language.\n"}},{"slug":"map-vs-andthen","frontmatter":{"title":"When To Use Which - map vs. andThen","description":""},"markdown":{"content":"\nmap and andThen are very similar operations and so developers new to functors and monads are often confused about when to apply which operations. The easiest way to make that decision is to allow the types to guide you. But if you are also new to type systems, this is not very helpful advice. So let’s walk through an example following the types.\n\n## The Types\n\nFor our contrived example, we’ll assume we are working with a simple library for converting dates to strings and strings to date. This library consists of two functions. Their type signatures are presented here:\n\n```typescript\nconst dateToString = (date: Date) =\u003e string;\n\nconst stringToDate = (candidate: string) =\u003e Maybe\u003cDate\u003e;\n```\n\nEven without the implementations, these type signatures convey a lot of information. The `dateToString` function maps a Date type to a string type, and every Date can be converted to a string. The `stringToDate` function maps a string to a Date, but since it returns `Maybe\u003cDate\u003e` we know that not every string produces a valid date.\n\n## Map\n\nGiven that we have a type of `Maybe\u003cDate\u003e`, then we will have functor and monad interfaces with the following type signatures:\n\n```typescript\n.map\u003cS\u003e(fn:  (value:  Date)  =\u003e  S):  Maybe\u003cS\u003e\n\n.andThen\u003cS\u003e(fn:  (value:  Date)  =\u003e  Maybe\u003cS\u003e):  Maybe\u003cS\u003e\n```\n\nIf we are hoping to convert the Date to a string, then we must use `dateToString`. In this scenario, one of these interfaces will never work. Using `dateToString` with `andThen` will not even compile. So our only option here is to use `map`.\n\nUsing `dateToString` converts our functor type signature to this:\n\n```typescript\n.map\u003cstring\u003e(dateToString): Maybe\u003cstring\u003e\n```\n\nI’m being explicit here, but typescript will infer the return type from the function being passed. So in practice, this can usually just be written as:\n\n```typescript\n.map(dateToString)\n```\n\nThis is what makes functors extremely powerful. We can now use this simple function in any context that is represented by a functor (ie. implements `map`). Result, Task, Decoder, NonEmptyList, Array; this function will work unchanged in any of them.\n\n## AndThen\n\nGiven a type of `Maybe\u003cstring\u003e`, then we will have functor and monad interfaces with the following type signatures:\n\n```typescript\n.map\u003cS\u003e(fn:  (value:  string)  =\u003e  S):  Maybe\u003cS\u003e\n\n.andThen\u003cS\u003e(fn:  (value:  string)  =\u003e  Maybe\u003cS\u003e):  Maybe\u003cS\u003e\n```\n\nIf we need to convert the string to a Date, then we will need to use our `stringToDate` function. We can use `.map` in this case too, but it may not be what we want. Let’s look at the type signature and see why that might be.\n\n```typescript\n.map\u003cMaybe\u003cDate\u003e\u003e(stringToDate):  Maybe\u003cMaybe\u003cDate\u003e\u003e\n```\n\nThis will compile, but you can see that we have a Maybe type nested within another Maybe. This nesting of a monad within the same type of monad is a red flag for maintainability and clarity. Let’s see what happens when we use the monad interface:\n\n```typescript\n.andThen\u003cDate\u003e(stringToDate):  Maybe\u003cDate\u003e\n```\n\nThis is much easier to maintain. We lose the nesting when we use the monad interface.\n\nThe downside to the monad interface is that our `stringToDate` function is specific to Maybe. This requires us to write new versions of the function to work with other monads. However, it is easy enough to convert a Maybe type to other monads as appropriate. In fact, `toResult` and `toTask` helpers already exist for converting between these types.\n\n## Summary\n\nHopefully, this helps to clarify when it is best to use `map` vs. `andThen`.\n"}},{"slug":"monads","frontmatter":{"title":"When To Use Which - Maybe vs Result vs Task (and other Monads)","description":""},"markdown":{"content":"\nThere is often confusion about when to use each of these types since they have such similar interfaces.\n\nThe first thing to understand about these types is that their similarity is because they are all Monads. All monads will have the same interface, though they may have different uses. In some cases, the difference will be obvious. In some cases, it may be just the difference of intent. We’ll explore these differences by first looking at monads that have obviously different purposes.\n\n## Monads\n\nA Monad is a data abstraction that allows programs to be structured generically. A particular Monad represents a specific form of computation. The consistent interface allows programs to look the same, regardless of the nature of the computation being performed.\n\nWe’ll discuss the most commonly used monads in our system here, but there is no real limit to the types of computations that monads can represent. But the goal of the abstraction is to separate the lower-level abstraction from the higher-level abstraction, level the purpose of the code clear.\n\n### Lists (Nonempty Lists)\n\nA List monad is used when we are expecting the result of a computation to be indeterminate. If I ask for people named “Smith”, I may be zero people or I may get 100 people. The key is that I don’t know ahead of time how large the result set of the computation is.\n\nIn the case of a non-empty list, the computation is expected to produce at least one result.\n\n### Decoders\n\nA decoder is used when a computation must rely on an unknown data type. With decoders, we can validate unknown data and transform it into something useful in the application context.\n\n### Maybe\n\nMaybe is used for computations that may fail, but the failure either isn’t an error condition, or the reason for the failure isn’t important. For example, using our find function on an array returns a Maybe type, because the value may not be in the array.\n\nMaybe is strongly preferred over using null, undefined, empty string, -1, or any other imperative style representations of computational failure.\n\n### Result\n\nResult is used for computations that may fail, but the reason for the failure is important. Decoders use Result types internally to handle the error reporting.\n\n### Task\n\nA Task is used for computations that may fail and the reason for failure is important. They differ from Results though because it is a lazy abstraction. The computation isn’t run until the Task is forked. This makes Tasks ideal for asynchronous operations.\n\nTasks are more determinate and have fewer foot guns than Promises.\n"}}],"navTree":[{"title":"Guide","links":[{"title":"Maybe Adapter","href":"/guide/maybe"},{"title":"CooperTS - Practical Patterns","href":"/guide/practical-patterns"},{"title":"Translations Package","href":"/guide/translations"}]},{"title":"Packages","links":[{"title":"ajaxian","href":"/packages/ajaxian"},{"title":"ajaxios","href":"/packages/ajaxios"},{"title":"@kofno/cute","href":"/packages/cute"},{"title":"@kofno/gaia","href":"/packages/gaia"},{"title":"jsonous","href":"/packages/jsonous"},{"title":"maybeasy","href":"/packages/maybeasy"},{"title":"nonempty-list","href":"/packages/nonempty-list"},{"title":"@kofno/piper","href":"/packages/piper"},{"title":"resulty","href":"/packages/resulty"},{"title":"@kofno/stack-ts","href":"/packages/stack-ts"},{"title":"taskarian","href":"/packages/taskarian"},{"title":"@execonline-inc/appy","href":"/packages/appy"},{"title":"@execonline-inc/collections","href":"/packages/collections"},{"title":"@execonline-inc/decoders","href":"/packages/decoders"},{"title":"@execonline-inc/dom","href":"/packages/dom"},{"title":"@execonline-inc/environment","href":"/packages/environment"},{"title":"@execonline-inc/error-handling","href":"/packages/error-handling"},{"title":"@execonline-inc/logging","href":"/packages/logging"},{"title":"@execonline-inc/maybe-adapter","href":"/packages/maybe-adapter"},{"title":"@execonline-inc/numbers","href":"/packages/numbers"},{"title":"@execonline-inc/resource","href":"/packages/resource"},{"title":"@execonline-inc/strings","href":"/packages/strings"},{"title":"@execonline-inc/time","href":"/packages/time"},{"title":"@execonline-inc/time-distance","href":"/packages/time-distance"},{"title":"@execonline-inc/translations","href":"/packages/translations"},{"title":"@execonline-inc/url","href":"/packages/url"}]},{"title":"Frequently Asked Questions","links":[{"title":"What's All This About Map Then?","href":"/faq/about-map"},{"title":"Avoiding The Billion Dollar Mistake","href":"/faq/billion-dollar-mistake"},{"title":"When to Use Which - getOrElse vs getOrElseValue","href":"/faq/getorelse-vs-getorelsevalue"},{"title":"Imperative vs Declarative Programming","href":"/faq/imperative-vs-declarative"},{"title":"When To Use Which - map vs. andThen","href":"/faq/map-vs-andthen"},{"title":"When To Use Which - Maybe vs Result vs Task (and other Monads)","href":"/faq/monads"}]}]},"__N_SSG":true},"page":"/faq","query":{},"buildId":"RrKv9ioTm-oJIK2k8EiP8","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>